<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>OSChina</title><link>http://my.oschina.net</link><description>2016-07-12</description><generator>PyRSS2Gen-1.1.0</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>cookie存储数组问题
        -  朱宝鑫的个人空间 - 开源中国社区</title><link>http://my.oschina.net/zhubaoxin/blog/710835</link><description>&lt;div class="BlogContent"&gt;&lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>springMVC笔记系列(23)——拦截器及其在乱码问题和登录问题的应用实现
        -  HappyBKs的Research Center - 开源中国社区</title><link>http://my.oschina.net/happyBKs/blog/710833</link><description>&lt;div class="BlogContent"&gt;
                    &lt;p&gt;&lt;strong&gt;&lt;span style="font-size:22px"&gt;拦截器的概念&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;A：“什么是拦截器？”&lt;/p&gt; 
&lt;p&gt;B：“拦截器是通过统一拦截从客户端发往服务器的请求来完成功能的增强。”&lt;/p&gt; 
&lt;p&gt;A：(一脸懵逼)&lt;/p&gt; 
&lt;p&gt;B：“说得简单点，拦截器就是在客户端向服务器端发出请求的期间，在请求交友服务器处理之前或之后对请求数据做一些修改或者其他相关的操作。”&lt;/p&gt; 
&lt;p&gt;A：“能说说具体实现什么功能吗？”&lt;/p&gt; 
&lt;p&gt;B：“拦截器的使用场景是解决一些共性问题。比如乱码问题、权限验证问题。你可以将这些共性的操作从各个不同业务功能的控制器方法中抽离出来，放在统一的拦截器中执行，这样你的解决乱码问题的代码，或者权限验证的代码不会重复地出现在各个不同业务功能对应的控制器方法执行体中。”&lt;/p&gt; 
&lt;p&gt;A：“我可以理解为拦截器是看门狗吗？这只狗负责看门，监管进门和出门的人；这只狗也能不同人家的门前做相同的事情——拦截出门或进门的人们。”&lt;/p&gt; 
&lt;p&gt;B：“能文雅点吗。。。”&lt;/p&gt; 
&lt;p&gt;A：“springMVC拦截器的出现倒是帮我们在MVC实现时，营造了一种AOP的效果”&lt;/p&gt; 
&lt;p&gt;B：“spring大法万岁！”&lt;/p&gt; 
&lt;p&gt;A：“。。。”&lt;/p&gt; 
&lt;p&gt;好，小段子结束，还是用博客的正常写法来写吧。&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;这里，也许你还要问——拦截器和过滤器有什么区别？&lt;/p&gt; 
&lt;p&gt;过滤器Filter依赖于Servlet容器，Filter被Servlet容器所管理；基于回调函数；过滤范围大（请求、资源等）&lt;/p&gt; 
&lt;p&gt;拦截器Interceptor依赖于springMVC框架容器；基于反射机制；只过滤请求&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#FFFFFF"&gt;(本文出自happyBKs的博客：http://my.oschina.net/happyBKs/blog/710833)&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:24px"&gt;&lt;strong&gt;springMVC拦截器的原理和使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;我们还是先来看一个应用场景：解决乱码问题。&lt;/p&gt; 
&lt;p&gt;利用SpringMVC的拦截器可以解决乱码问题。但是，你应该会说，我使用Servlet容器中的过滤器也可以完成。是的，现在我们现在一个springMVC项目中通过配置一个过滤器来解决乱码问题。（实际上springMVC拦截器与Servlet容器中的过滤器在实现解决乱码问题时的原理十分相似）&lt;/p&gt; 
&lt;p&gt;我们在前几篇博客文章的例子的基础上改代码吧，顺便说明一下一个springMVC可以有两个互不干扰的前端控制器配置。在web.xml中，我们在最后追加一个前端控制器viewSpace-dispatcher。可以看到，这个web.xml配置文件中有两个org.springframework.web.servlet.DispatcherServlet。但是拦截的请求是不同的，一个是/，一个是/test2/*。这里请求会自动匹配更具体的一个，关于各种url通配符优先级，改天我专门弄一篇博客来说。&lt;/p&gt; 
&lt;p&gt;关于web.xml的servlet的url-pattern，我只想插入一个注意事项：&lt;/p&gt; 
&lt;p&gt;在web.xml文件中，以下语法用于定义映射： &lt;/p&gt; 
&lt;p&gt;l. 以”/’开头和以”/*”结尾的是用来做&lt;strong&gt;路径映射&lt;/strong&gt;的。 &lt;/p&gt; 
&lt;p&gt;2. 以前缀”*.”开头的是用来做&lt;strong&gt;扩展映射&lt;/strong&gt;的。 &lt;/p&gt; 
&lt;p&gt;3. “/” 是用来定义&lt;strong&gt;default servlet映射&lt;/strong&gt;的。 &lt;/p&gt; 
&lt;p&gt;4. 剩下的都是用来定义&lt;strong&gt;详细映射&lt;/strong&gt;的。比如： /aa/bb/cc.action &lt;/p&gt; 
&lt;p&gt;所以，为什么定义”/*.action”这样一个看起来很正常的匹配会错？因为这个匹配即属于路径映射，也属于扩展映射，导致容器无法判断。&lt;/p&gt; 
&lt;p&gt;言归正传，下面是web.xml，重点看最后的那个viewSpace-dispatcher：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd " version="2.5"&amp;gt;

  &amp;lt;display-name&amp;gt;Archetype Created Web Application&amp;lt;/display-name&amp;gt;

  &amp;lt;!-- Spring应用上下文， 理解层次化的ApplicationContext --&amp;gt;
    &amp;lt;context-param&amp;gt;
      &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;/WEB-INF/configs/spring/applicationContext*.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;

    &amp;lt;listener&amp;gt;
      &amp;lt;listener-class&amp;gt;
        org.springframework.web.context.ContextLoaderListener
      &amp;lt;/listener-class&amp;gt;
    &amp;lt;/listener&amp;gt;

  &amp;lt;!-- DispatcherServlet, Spring MVC的核心 --&amp;gt;
  &amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;mvc-dispatcher&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt; org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;!-- DispatcherServlet对应的上下文配置， 默认为/WEB-INF/$servlet-name$-servlet.xml
     --&amp;gt;
    &amp;lt;init-param&amp;gt;
      &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;/WEB-INF/configs/spring/mvc-dispatcher-servlet.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
  &amp;lt;/servlet&amp;gt;
  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;mvc-dispatcher&amp;lt;/servlet-name&amp;gt;
    &amp;lt;!-- mvc-dispatcher拦截所有的请求--&amp;gt;
    &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/servlet-mapping&amp;gt;


  &amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;viewSpace-dispatcher&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt; org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;!-- DispatcherServlet对应的上下文配置， 默认为/WEB-INF/$servlet-name$-servlet.xml
     --&amp;gt;
    &amp;lt;init-param&amp;gt;
      &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;/WEB-INF/configs/spring/viewSpace-dispatcher-servlet.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
  &amp;lt;/servlet&amp;gt;
  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;viewSpace-dispatcher&amp;lt;/servlet-name&amp;gt;
    &amp;lt;!-- mvc-dispatcher拦截所有的请求--&amp;gt;
    &amp;lt;url-pattern&amp;gt;/test2/*&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/servlet-mapping&amp;gt;



&amp;lt;/web-app&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;然后我们编写viewSpace-dispatcher的配置文件：&lt;/p&gt; 
&lt;p&gt;&lt;img height="408" src="http://static.oschina.net/uploads/space/2016/0709/231555_UmFK_1156339.png" width="406"/&gt;&lt;/p&gt; 
&lt;p&gt;\WEB-INF\configs\spring\viewSpace-dispatcher-servlet.xml如下：(具体含义可以参加前面的文章)&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"&amp;gt;

    &amp;lt;!-- 本配置文件是工名为mvc-dispatcher的DispatcherServlet使用， 提供其相关的Spring MVC配置 --&amp;gt;

    &amp;lt;!-- 启用Spring基于annotation的DI, 使用户可以在Spring MVC中使用Spring的强大功能。 激活 @Required
        @Autowired,JSR 250's @PostConstruct, @PreDestroy and @Resource 等标注 --&amp;gt;
    &amp;lt;context:annotation-config /&amp;gt;

    &amp;lt;!-- DispatcherServlet上下文， 只管理@Controller类型的bean， 忽略其他型的bean, 如@Service --&amp;gt;
    &amp;lt;context:component-scan base-package="com.happyBKs.controller"&amp;gt;
        &amp;lt;context:include-filter type="annotation"  expression="org.springframework.stereotype.Controller" /&amp;gt;
    &amp;lt;/context:component-scan&amp;gt;

    &amp;lt;!-- HandlerMapping, 无需配置， Spring MVC可以默认启动。 DefaultAnnotationHandlerMapping
        annotation-driven HandlerMapping --&amp;gt;

    &amp;lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&amp;gt;
    &amp;lt;mvc:annotation-driven /&amp;gt;

    &amp;lt;!-- 静态资源处理， css， js， imgs --&amp;gt;
    &amp;lt;mvc:resources mapping="/resources/**" location="/resources/" /&amp;gt;


    &amp;lt;!-- 配置ViewResolver。 可以用多个ViewResolver。 使用order属性排序。 InternalResourceViewResolver放在最后。 --&amp;gt;
    &amp;lt;bean
            class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&amp;gt;
        &amp;lt;property name="order" value="1"/&amp;gt;
        &amp;lt;!--&amp;lt;property name="mediaTypes"&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;map&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;entry key="json" value="application/json"/&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;entry key="xml" value="application/xml"/&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;entry key="htm" value="text/html"/&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;/map&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;/property&amp;gt;--&amp;gt;

        &amp;lt;property name="defaultViews"&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;!-- JSON View --&amp;gt;
                &amp;lt;bean
                        class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"&amp;gt;
                &amp;lt;/bean&amp;gt;
            &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!--&amp;lt;property name="ignoreAcceptHeader" value="true"/&amp;gt;--&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean
            class="org.springframework.web.servlet.view.InternalResourceViewResolver"&amp;gt;
        &amp;lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&amp;gt;
        &amp;lt;property name="prefix" value="/WEB-INF/jsps/" /&amp;gt;
        &amp;lt;property name="suffix" value=".jsp" /&amp;gt;
    &amp;lt;/bean&amp;gt;


    &amp;lt;!--200*1024*1024即200M resolveLazily属性启用是为了推迟文件解析，以便捕获文件大小异常 --&amp;gt;
    &amp;lt;bean id="multipartResolver"
          class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&amp;gt;
        &amp;lt;property name="maxUploadSize" value="209715200"/&amp;gt;
        &amp;lt;property name="defaultEncoding" value="UTF-8"/&amp;gt;
        &amp;lt;property name="resolveLazily" value="true"/&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;之后我们变量一个控制器TestController2 ：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;package com.happyBKs.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;

/**
 * Created by sunsun on 2016/7/9.
 */

@Controller
@RequestMapping("/test2")
public class TestController2 {

    @RequestMapping("/login")
    public String login(){
        System.out.println("进入控制器的login方法");
        return "login";
    }

    @RequestMapping("/viewAll")
    public ModelAndView viewAll(@RequestParam("name") String name,@RequestParam("pwd") String pwd){
        ModelAndView mv = new ModelAndView();
        System.out.println("进入控制器的viewAll方法");
        System.out.println("name="+name);
        System.out.println("pwd="+pwd);
        mv.setViewName("/hello");
        return mv;
    }


}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这个控制器的两个方法，一个是分发访问登录页面的请求，一个是接收登录请求并将表单数据在控制台输出最终转到hello页面。&lt;/p&gt; 
&lt;p&gt;登录页面\WEB-INF\jsps\login.jsp：（本项目是之前博客中的项目例子基础上追加的功能，原项目定义了webapp的url名称为mvc，所以表单action的请求路径请注意！）&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;%--
  Created by IntelliJ IDEA.
  User: happyBKs
  Date: 2016/7/9
  Time: 13:22
  To change this template use File | Settings | File Templates.
--%&amp;gt;
&amp;lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;登录&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form action="/mvc/test2/viewAll" method="post"&amp;gt;
    用户名&amp;lt;input type="text" name="name" id="name"&amp;gt;&amp;lt;br/&amp;gt;
    密 码&amp;lt;input type="password" name="pwd" id="pwd"&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type="submit" name="登录"&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;登录后的hello页面：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;%--
  Created by IntelliJ IDEA.
  User: happyBKs
  Date: 2016/7/9
  Time: 14:42
  To change this template use File | Settings | File Templates.
--%&amp;gt;
&amp;lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;成功登录&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
成功登录
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;之后我们发布项目到tomcat，但是请求http://localhost:8080/mvc/test2/login，却提示404错误。&lt;/p&gt; 
&lt;p&gt;&lt;img height="252" src="http://static.oschina.net/uploads/space/2016/0712/172632_bgSq_1156339.png" width="650"/&gt;&lt;/p&gt; 
&lt;p&gt;控制台输出：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-html"&gt;19680 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet  - DispatcherServlet with name 'viewSpace-dispatcher' processing GET request for [/mvc/test2/login]
19680 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet  - DispatcherServlet with name 'viewSpace-dispatcher' processing GET request for [/mvc/test2/login]
19686 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping  - Looking up handler method for path /login
19686 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping  - Looking up handler method for path /login
19689 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping  - Did not find handler method for [/login]
19689 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping  - Did not find handler method for [/login]
19690 [http-apr-8080-exec-10] WARN  org.springframework.web.servlet.PageNotFound  - No mapping found for HTTP request with URI [/mvc/test2/login] in DispatcherServlet with name 'viewSpace-dispatcher'
19690 [http-apr-8080-exec-10] WARN  org.springframework.web.servlet.PageNotFound  - No mapping found for HTTP request with URI [/mvc/test2/login] in DispatcherServlet with name 'viewSpace-dispatcher'
19690 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet  - Successfully completed request
19690 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet  - Successfully completed request&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style="color:#0000FF"&gt;这是为什么呢？&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#FF0000"&gt;原因是，当一个请求的全路径通过servlet映射找到所服务的DispatcherServlet后，DispatcherServlet按照url-pattern路径映射的匹配后剩余的路径进一步交给DispatcherServlet，由DispatcherServlet进一步实现剩下路径在其搜索包空间内的控制器类的请求映射的匹配。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#FF0000"&gt;回到这个例子中就是：http://localhost:8080/mvc/test2/login中，首先去除了域名和端口/mvc/test2/login，tomcat中配置了应用上下文Application Context为mvc，所以springMVC项目处理的请求为/test2/login。在web.xml中由viewSpace-dispatcher因url-pattern为/test2/**接收请求/test2/login，然后将匹配剩余部分路径/login进一步交给viewSpace-dispatcher所对应的springMVC容器配置文件中定义的控制器类包搜索空间中搜索能够匹配这个请求/login的控制器及其方法。但是这里我们原本希望其能够映射到的控制器类TestController2的@RequestMappping的注解值又配置了一个/test2，原本我们希望的目标方法public String login()的@RequestMappping注解值为/login。这时候实际springMVC是将请求/login尝试与/test2/login进行匹配，当然不可能匹配上，所以才会在控制台输出请求匹配不了，整个请求也只能返回404。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;你若不信，当我们这时候请求http://localhost:8080/mvc/test2/test2/login，你会发现尽然正常显示了！！&lt;/p&gt; 
&lt;p&gt;&lt;img height="163" src="http://static.oschina.net/uploads/space/2016/0712/174652_XxGJ_1156339.png" width="622"/&gt;&lt;/p&gt; 
&lt;p&gt;所以我们就将控制器类TestController2的映射路径改为“/”，这样就可以了。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;package com.happyBKs.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;

/**
 * Created by sunsun on 2016/7/9.
 */

@Controller
@RequestMapping("/")
public class TestController2 {

    @RequestMapping("/login")
    public String login(){
        System.out.println("进入控制器的login方法...");
        return "login";
    }

    @RequestMapping("/viewAll")
    public ModelAndView viewAll(@RequestParam("name") String name,@RequestParam("pwd") String pwd){
        ModelAndView mv = new ModelAndView();
        System.out.println("进入控制器的viewAll方法...");
        System.out.println("name="+name);
        System.out.println("pwd="+pwd);
        mv.setViewName("/hello");
        return mv;
    }


}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;我们来看看运行结果：&lt;/p&gt; 
&lt;p&gt;请求http://localhost:8080/mvc/test2/login&lt;/p&gt; 
&lt;p&gt;&lt;img height="145" src="http://static.oschina.net/uploads/space/2016/0709/232803_c7WA_1156339.png" width="594"/&gt;&lt;/p&gt; 
&lt;p&gt;控制台输出：&lt;/p&gt; 
&lt;p&gt;&lt;img height="135" src="http://static.oschina.net/uploads/space/2016/0709/232602_wHrP_1156339.png" width="292"/&gt;&lt;/p&gt; 
&lt;p&gt;提交表单之后，转到http://localhost:8080/mvc/test2/viewAll：&lt;/p&gt; 
&lt;p&gt;&lt;img height="149" src="http://static.oschina.net/uploads/space/2016/0709/232744_5TOU_1156339.png" width="562"/&gt;&lt;/p&gt; 
&lt;p&gt;控制台输出：&lt;/p&gt; 
&lt;p&gt;&lt;img height="155" src="http://static.oschina.net/uploads/space/2016/0709/232652_4HXF_1156339.png" width="288"/&gt;&lt;/p&gt; 
&lt;p&gt;可以看到中文数据出现了乱码。。。。。。。&lt;/p&gt; 
&lt;p&gt;springMVC在框架中已经为web的过滤器提供了一个CharacterEncodingFilter类&lt;/p&gt; 
&lt;p&gt;&lt;img height="370" src="http://static.oschina.net/uploads/space/2016/0709/233001_mBId_1156339.png" width="392"/&gt;&lt;/p&gt; 
&lt;p&gt; 在web.xml中，增加一个过滤器：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;  &amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;viewSpace-filter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt;
    &amp;lt;init-param&amp;gt;
      &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;utf8&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
  &amp;lt;/filter&amp;gt;
  &amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;viewSpace-filter&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/test2/*&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/filter-mapping&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这个过滤器指定/test2/*符合该通配符的url请求都会被这个过滤器过滤到，然后交由这个CharacterEncodingFilter来处理，将请求参数中的数据编码转换成utf8。&lt;/p&gt; 
&lt;p&gt;注意：这个不同用/test2，而要使用完整的通配符，否则过滤器会以为你仅仅是要过滤http://localhost:8080/mvc/test2一个url请求，这与前端控制器的url-pattern不同，需要特别注意。&lt;/p&gt; 
&lt;p&gt;我们按照刚才的方法运行请求：&lt;/p&gt; 
&lt;p&gt;&lt;img height="155" src="http://static.oschina.net/uploads/space/2016/0710/134618_efsj_1156339.png" width="550"/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="111" src="http://static.oschina.net/uploads/space/2016/0710/134634_KT3x_1156339.png" width="566"/&gt;&lt;/p&gt; 
&lt;p&gt;控制台输出发现参数已经不会再出现中文乱码了。&lt;/p&gt; 
&lt;p&gt;&lt;img height="144" src="http://static.oschina.net/uploads/space/2016/0710/134712_fhuG_1156339.png" width="325"/&gt;&lt;/p&gt; 
&lt;p&gt;好，过滤器就像一个检票口，符合特定条件的请求进入者可以经过相应一些手续后进入。过滤器和拦截器在功能上可以说是十分相似的，只是在一些细节上有所不同，下面，我们来看看拦截器如何实现。&lt;/p&gt; 
&lt;p&gt;拦截器的实现步骤如下：&lt;/p&gt; 
&lt;p&gt;1. 首先编写一个拦截器类，须要实现HandlerInterceptor接口：&lt;/p&gt; 
&lt;p&gt;&lt;img height="340" src="http://static.oschina.net/uploads/space/2016/0712/175141_wKDi_1156339.png" width="372"/&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;package com.happyBKs.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;

/**
 * Created by happyBKs on 2016/7/9.
 */

@Controller
@RequestMapping("/")
public class TestController2 {

    @RequestMapping("/login")
    public String login(){
        System.out.println("进入控制器的login方法...");
        return "login";
    }

    @RequestMapping("/viewAll")
    public ModelAndView viewAll(@RequestParam("name") String name,@RequestParam("pwd") String pwd){
        ModelAndView mv = new ModelAndView();
        System.out.println("进入控制器的viewAll方法...");
        System.out.println("name="+name);
        System.out.println("pwd="+pwd);
        mv.setViewName("/hello");
        return mv;
    }


}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;2.将拦截器注册到springMVC框架中：&lt;/p&gt; 
&lt;p&gt;注意，在这个前端控制器器配置文件中，必须声明&lt;/p&gt; 
&lt;p&gt;xmlns:mvc="http://www.springframework.org/schema/mvc"&lt;/p&gt; 
&lt;p&gt;http://www.springframework.org/schema/mvc/spring-mvc.xsd"&lt;/p&gt; 
&lt;p&gt;应为拦截器须要用到mvc的名称空间：&lt;/p&gt; 
&lt;p&gt;我们在\WEB-INF\configs\spring\viewSpace-dispatcher-servlet.xml中追加如下内容：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;    &amp;lt;mvc:interceptors&amp;gt;
        &amp;lt;mvc:interceptor&amp;gt;
            &amp;lt;mvc:mapping path="/**"/&amp;gt;
            &amp;lt;bean class="com.happyBKs.interceptor.TestInterceptor"&amp;gt;&amp;lt;/bean&amp;gt;
        &amp;lt;/mvc:interceptor&amp;gt;
    &amp;lt;/mvc:interceptors&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;注意：这里的，mvc:mapping的path属性配置的路径必须是“/**”，而不能是“/”或者“/*”。&lt;/p&gt; 
&lt;p&gt;&lt;br/&gt; /**的意思是所有文件夹及里面的子文件夹&lt;br/&gt; /*是所有文件夹，不含子文件夹&lt;br/&gt; /是web项目的根目录&lt;/p&gt; 
&lt;p&gt;然后可以看到请求http://localhost:8080/mvc/test2 结果控制台输出：拦截器的三个方法与控制器方法的执行顺序可以看见了吧。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-html"&gt;执行进入preHandle方法
进入控制器的login方法...
执行进入postHandle方法
11705 [http-apr-8080-exec-10] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory  - Invoking afterPropertiesSet() on bean with name 'login'
11705 [http-apr-8080-exec-10] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory  - Invoking afterPropertiesSet() on bean with name 'login'
11705 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet  - Rendering view [org.springframework.web.servlet.view.JstlView: name 'login'; URL [/WEB-INF/jsps/login.jsp]] in DispatcherServlet with name 'viewSpace-dispatcher'
11705 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet  - Rendering view [org.springframework.web.servlet.view.JstlView: name 'login'; URL [/WEB-INF/jsps/login.jsp]] in DispatcherServlet with name 'viewSpace-dispatcher'
11714 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.view.JstlView  - Forwarding to resource [/WEB-INF/jsps/login.jsp] in InternalResourceView 'login'
11714 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.view.JstlView  - Forwarding to resource [/WEB-INF/jsps/login.jsp] in InternalResourceView 'login'
执行进入afterCompletion方法&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;拦截器的方法&lt;/p&gt; 
&lt;p&gt;下面我们来详细说说拦截器的三个方法：&lt;/p&gt; 
&lt;p&gt;preHandle：在请求备注里之前进行调用&lt;/p&gt; 
&lt;p&gt;postHandle：在请求被处理之后进行调用&lt;/p&gt; 
&lt;p&gt;afterComletion：在请求结束之后才进行调用&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;preHandle方法与其他两个方法相比比较特殊，它是具有返回值的。这个boolean类型的返回值表示这个请求是否能“活命”。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("执行进入preHandle方法");
        return true;
    }&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;返回值为true表示，在preHandle执行完之后请求继续传递下去；为false，请求被拦截后就终止请求了。&lt;/p&gt; 
&lt;p&gt;如果我们把这个方法的返回值改成false，控制台输出结果和页面显示如下：&lt;/p&gt; 
&lt;p&gt;&lt;img height="123" src="http://static.oschina.net/uploads/space/2016/0712/204052_1SXO_1156339.png" width="765"/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="251" src="http://static.oschina.net/uploads/space/2016/0712/204106_KoHo_1156339.png" width="611"/&gt;&lt;/p&gt; 
&lt;p&gt;看到了请求没有被执行下去，连控制器方法都没有被执行，所以这个请求被拦截下懒之后被拦截器给扼杀在摇篮里了。&lt;/p&gt; 
&lt;p&gt;这三个方法的形参都具有HttpServletRequest request和HttpServletResponse response，前者包含了所有的请求内容，后者包含了所有的响应内容。&lt;/p&gt; 
&lt;p&gt;preHandle方法里的Object handler表示的是被拦截的请求目标对象。比如，这个例子中请求拦截的目标就是这个TestController2。&lt;/p&gt; 
&lt;p&gt;postHandle方法里的独有的参数ModelAndView modelAndView：我们可以通过该参数改变显示的视图，或者修改发往视图的方法。看到了吧，即使你在控制器方法中已经对映射的视图资源做了设定，这里依然可以更改。这个更改既包括这请求映射到那个视图资源，还包括了传递给视图资源的数据等。&lt;/p&gt; 
&lt;p&gt;这里我们举个例子，加入我们在控制器TestController2中增加一个方法：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;    @RequestMapping("/msg")
    public ModelAndView msg(){
        System.out.println("进入控制器的msg方法...");
        ModelAndView mv=new ModelAndView();
        mv.setViewName("/InterTest");
        mv.addObject("msg","从控制器的方法返回的视图数据");
        return mv;
    }&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;增加一个jsp视图页面\WEB-INF\jsps\InterTest.jsp：&lt;/p&gt; 
&lt;p&gt;&lt;img height="359" src="http://static.oschina.net/uploads/space/2016/0712/213032_wLsN_1156339.png" width="246"/&gt;&lt;/p&gt; 
&lt;p&gt;注意：这里msg数据用的EL表达式的形式${msg}。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;%--
  Created by IntelliJ IDEA.
  User: sunsun
  Date: 2016/7/12
  Time: 20:58
  To change this template use File | Settings | File Templates.
--%&amp;gt;
&amp;lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;拦截器测试&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
msg=${msg}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;然后我们运行请求http://localhost:8080/mvc/test2/msg&lt;/p&gt; 
&lt;p&gt;&lt;img height="127" src="http://static.oschina.net/uploads/space/2016/0712/213213_JKKQ_1156339.png" width="633"/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;好，这时候，我们在原先的拦截器类TestInterceptor类的postHandle方法上做个修改：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("执行进入postHandle方法");
        //通过modelAndView参数改变显示的视图，或者修改发往视图的方法
        modelAndView.addObject("msg","被拦截器的postHandle方法修改后的视图数据");

    }&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;我们再次运行方才的项目，请求：http://localhost:8080/mvc/test2/msg&lt;/p&gt; 
&lt;p&gt;&lt;img height="118" src="http://static.oschina.net/uploads/space/2016/0712/213923_fDsF_1156339.png" width="554"/&gt;&lt;/p&gt; 
&lt;p&gt;看到了吧，msg的数据已经是被拦截器的postHandle方法修改后的数据了。&lt;/p&gt; 
&lt;p&gt;并且，控制台输出也表明，执行的各个环节依然还在。&lt;/p&gt; 
&lt;p&gt;&lt;img height="310" src="http://static.oschina.net/uploads/space/2016/0712/214030_QSol_1156339.png" width="298"/&gt;&lt;/p&gt; 
&lt;p&gt;当然，这里的拦截器还可以对请求转发的视图资源做更改。例如，我们继续更改控制器类的postHandle方法：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("执行进入postHandle方法");
        //通过modelAndView参数改变显示的视图，或者修改发往视图的方法
        modelAndView.addObject("msg","被拦截器的postHandle方法修改后的视图数据");
        modelAndView.setViewName("/hello");

    }&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;将modelAndView的视图资源设置为hello页面，即成功登录页面\WEB-INF\jsps\hello.jsp&lt;/p&gt; 
&lt;p&gt;运行结果变为：&lt;/p&gt; 
&lt;p&gt;&lt;img height="128" src="http://static.oschina.net/uploads/space/2016/0712/214525_8cAg_1156339.png" width="528"/&gt;&lt;/p&gt; 
&lt;p&gt;看吧，视图资源也能换。&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;afterCompletion方法有点像C++中的析构函数，afterCompletion方法在请求被响应之后最后执行，用于对一些资源的释放，对我们来说不是很常用。&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;下面我们来说明另外一个问题：如果存在多个拦截器，执行机制是怎么样的？&lt;/p&gt; 
&lt;p&gt;我们将定义两个拦截器TestController和TestController2&lt;/p&gt; 
&lt;p&gt;&lt;img height="175" src="http://static.oschina.net/uploads/space/2016/0712/215717_B2fg_1156339.png" width="286"/&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;package com.happyBKs.interceptor;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Created by happyBKs on 2016/7/10.
 */
public class TestInterceptor implements HandlerInterceptor {
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("执行进入TestInterceptor的preHandle方法");
        return true;
    }

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("执行进入TestInterceptor的postHandle方法");
        //通过modelAndView参数改变显示的视图，或者修改发往视图的方法
//        modelAndView.addObject("msg","被拦截器的postHandle方法修改后的视图数据");
//        modelAndView.setViewName("/hello");

    }

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("执行进入TestInterceptor的afterCompletion方法");
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;package com.happyBKs.interceptor;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Created by happyBKs on 2016/7/10.
 */
public class TestInterceptor2 implements HandlerInterceptor {
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("执行进入TestInterceptor2的preHandle方法");
        return true;
    }

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("执行进入TestInterceptor2的postHandle方法");
        //通过modelAndView参数改变显示的视图，或者修改发往视图的方法
//        modelAndView.addObject("msg","被拦截器的postHandle方法修改后的视图数据");
//        modelAndView.setViewName("/hello");

    }

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("执行进入TestInterceptor2的afterCompletion方法");
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;之后在springMVC前端控制器配置文件\WEB-INF\configs\spring\viewSpace-dispatcher-servlet.xml中配置：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"&amp;gt;


    &amp;lt;!-- 本配置文件是工名为mvc-dispatcher的DispatcherServlet使用， 提供其相关的Spring MVC配置 --&amp;gt;

    &amp;lt;!-- 启用Spring基于annotation的DI, 使用户可以在Spring MVC中使用Spring的强大功能。 激活 @Required
        @Autowired,JSR 250's @PostConstruct, @PreDestroy and @Resource 等标注 --&amp;gt;
    &amp;lt;context:annotation-config /&amp;gt;

    &amp;lt;!-- DispatcherServlet上下文， 只管理@Controller类型的bean， 忽略其他型的bean, 如@Service --&amp;gt;
    &amp;lt;context:component-scan base-package="com.happyBKs.controller"&amp;gt;
        &amp;lt;context:include-filter type="annotation"  expression="org.springframework.stereotype.Controller" /&amp;gt;
    &amp;lt;/context:component-scan&amp;gt;

    &amp;lt;!-- HandlerMapping, 无需配置， Spring MVC可以默认启动。 DefaultAnnotationHandlerMapping
        annotation-driven HandlerMapping --&amp;gt;

    &amp;lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&amp;gt;
    &amp;lt;mvc:annotation-driven /&amp;gt;


    &amp;lt;!-- 静态资源处理， css， js， imgs --&amp;gt;
    &amp;lt;mvc:resources mapping="/resources/**" location="/resources/" /&amp;gt;


    &amp;lt;!--&amp;lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;property name="alwaysUseFullPath" value="true"&amp;gt;&amp;lt;/property&amp;gt;--&amp;gt;
    &amp;lt;!--&amp;lt;/bean&amp;gt;--&amp;gt;

    &amp;lt;bean
            class="org.springframework.web.servlet.view.InternalResourceViewResolver"&amp;gt;
        &amp;lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&amp;gt;
        &amp;lt;property name="prefix" value="/WEB-INF/jsps/" /&amp;gt;
        &amp;lt;property name="suffix" value=".jsp" /&amp;gt;
    &amp;lt;/bean&amp;gt;


    &amp;lt;mvc:interceptors&amp;gt;
        &amp;lt;mvc:interceptor&amp;gt;
            &amp;lt;mvc:mapping path="/**"/&amp;gt;
            &amp;lt;bean class="com.happyBKs.interceptor.TestInterceptor"&amp;gt;&amp;lt;/bean&amp;gt;
        &amp;lt;/mvc:interceptor&amp;gt;
        &amp;lt;mvc:interceptor&amp;gt;
            &amp;lt;mvc:mapping path="/**"/&amp;gt;
            &amp;lt;bean class="com.happyBKs.interceptor.TestInterceptor2"&amp;gt;&amp;lt;/bean&amp;gt;
        &amp;lt;/mvc:interceptor&amp;gt;
    &amp;lt;/mvc:interceptors&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;然后我们运行，请求http://localhost:8080/mvc/test2/login&lt;/p&gt; 
&lt;p&gt;控制台输出结果：&lt;/p&gt; 
&lt;p&gt;执行进入TestInterceptor的preHandle方法&lt;br/&gt; 执行进入TestInterceptor2的preHandle方法&lt;br/&gt; 进入控制器的login方法...&lt;br/&gt; 执行进入TestInterceptor2的postHandle方法&lt;br/&gt; 执行进入TestInterceptor的postHandle方法&lt;br/&gt; 执行进入TestInterceptor2的afterCompletion方法&lt;br/&gt; 执行进入TestInterceptor的afterCompletion方法&lt;/p&gt; 
&lt;p&gt;是不是有点糊涂，不要紧，看看这个执行机制的示意图：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" height="671" src="http://static.oschina.net/uploads/space/2016/0712/220440_qYit_1156339.jpg" width="1045"/&gt;&lt;/p&gt; 
&lt;p&gt;打个比方说：比如你从上海去北京出差，有两个收费口，我们先经过,收费口1，然后经过2，达到北京，然后回来时先经过2，在经过1，并且，回来的过程中我告诉收费口把发票寄到上海家里，于是收费口2的发票先寄出，然后收费口1的再寄出。收费口就是拦截器，去北京的路上的收费口执行preHandle方法，到北京执行控制器方法，返程中收费口执行postHandle方法，开发票就是afterCompletion方法。&lt;/p&gt; 
&lt;p&gt;&lt;img height="132" src="http://static.oschina.net/uploads/space/2016/0712/220651_Lnqg_1156339.png" width="893"/&gt;&lt;/p&gt; 
&lt;p&gt;最后，在拦截器的实现方法上再补充一点，拦截器除了可以通过实现HandleInterceptor接口来完成，还有一种接口也可以——接口WebRequestInterCeptor。但是这种方法的preHandle方法没有返回值，因此不具有终止请求的功能。所以我还是推荐通过实现HandleInterceptor接口来完成。&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;SpringMVC拦截器的使用场景&lt;/p&gt; 
&lt;p&gt;使用原则：处理所有请求中的共性问题&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#0000FF"&gt;&lt;strong&gt;1. 解决乱码问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;我们将控制器TestInterceptor重新整理一下，对preHandle方法中的request参数设置一下编码。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;package com.happyBKs.interceptor;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Created by happyBKs on 2016/7/10.
 */
public class TestInterceptor implements HandlerInterceptor {
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("执行进入TestInterceptor的preHandle方法");
        request.setCharacterEncoding("utf-8");
        return true;
    }

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("执行进入TestInterceptor的postHandle方法");
    }

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("执行进入TestInterceptor的afterCompletion方法");
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;原先项目web.xml中的过滤器我们注释掉。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd " version="2.5"&amp;gt;

  &amp;lt;display-name&amp;gt;Archetype Created Web Application&amp;lt;/display-name&amp;gt;

  &amp;lt;!-- Spring应用上下文， 理解层次化的ApplicationContext --&amp;gt;
    &amp;lt;context-param&amp;gt;
      &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;/WEB-INF/configs/spring/applicationContext*.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;

    &amp;lt;listener&amp;gt;
      &amp;lt;listener-class&amp;gt;
        org.springframework.web.context.ContextLoaderListener
      &amp;lt;/listener-class&amp;gt;
    &amp;lt;/listener&amp;gt;

   &amp;lt;!--DispatcherServlet, Spring MVC的核心--&amp;gt;
  &amp;lt;!--&amp;lt;servlet&amp;gt;--&amp;gt;
    &amp;lt;!--&amp;lt;servlet-name&amp;gt;mvc-dispatcher&amp;lt;/servlet-name&amp;gt;--&amp;gt;
    &amp;lt;!--&amp;lt;servlet-class&amp;gt; org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;--&amp;gt;
    &amp;lt;!--&amp;amp;lt;!&amp;amp;ndash; DispatcherServlet对应的上下文配置， 默认为/WEB-INF/$servlet-name$-servlet.xml--&amp;gt;
     &amp;lt;!--&amp;amp;ndash;&amp;amp;gt;--&amp;gt;
    &amp;lt;!--&amp;lt;init-param&amp;gt;--&amp;gt;
      &amp;lt;!--&amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;--&amp;gt;
      &amp;lt;!--&amp;lt;param-value&amp;gt;/WEB-INF/configs/spring/mvc-dispatcher-servlet.xml&amp;lt;/param-value&amp;gt;--&amp;gt;
    &amp;lt;!--&amp;lt;/init-param&amp;gt;--&amp;gt;
    &amp;lt;!--&amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;--&amp;gt;
  &amp;lt;!--&amp;lt;/servlet&amp;gt;--&amp;gt;
  &amp;lt;!--&amp;lt;servlet-mapping&amp;gt;--&amp;gt;
    &amp;lt;!--&amp;lt;servlet-name&amp;gt;mvc-dispatcher&amp;lt;/servlet-name&amp;gt;--&amp;gt;
    &amp;lt;!--&amp;amp;lt;!&amp;amp;ndash; mvc-dispatcher拦截所有的请求&amp;amp;ndash;&amp;amp;gt;--&amp;gt;
    &amp;lt;!--&amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;--&amp;gt;
  &amp;lt;!--&amp;lt;/servlet-mapping&amp;gt;--&amp;gt;


  &amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;viewSpace-dispatcher&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt; org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;!-- DispatcherServlet对应的上下文配置， 默认为/WEB-INF/$servlet-name$-servlet.xml
     --&amp;gt;
    &amp;lt;init-param&amp;gt;
      &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;/WEB-INF/configs/spring/viewSpace-dispatcher-servlet.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
  &amp;lt;/servlet&amp;gt;
  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;viewSpace-dispatcher&amp;lt;/servlet-name&amp;gt;
    &amp;lt;!-- mvc-dispatcher拦截所有的请求--&amp;gt;
    &amp;lt;url-pattern&amp;gt;/test2/*&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/servlet-mapping&amp;gt;


&amp;lt;!--  &amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;viewSpace-filter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt;
    &amp;lt;init-param&amp;gt;
      &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;utf8&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
  &amp;lt;/filter&amp;gt;
  &amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;viewSpace-filter&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/test2/*&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/filter-mapping&amp;gt;--&amp;gt;

&amp;lt;/web-app&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;springMVC前端控制器配置文件\WEB-INF\configs\spring\viewSpace-dispatcher-servlet.xml也只保留一个拦截器注册：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"&amp;gt;


    &amp;lt;!-- 本配置文件是工名为mvc-dispatcher的DispatcherServlet使用， 提供其相关的Spring MVC配置 --&amp;gt;

    &amp;lt;!-- 启用Spring基于annotation的DI, 使用户可以在Spring MVC中使用Spring的强大功能。 激活 @Required
        @Autowired,JSR 250's @PostConstruct, @PreDestroy and @Resource 等标注 --&amp;gt;
    &amp;lt;context:annotation-config /&amp;gt;

    &amp;lt;!-- DispatcherServlet上下文， 只管理@Controller类型的bean， 忽略其他型的bean, 如@Service --&amp;gt;
    &amp;lt;context:component-scan base-package="com.happyBKs.controller"&amp;gt;
        &amp;lt;context:include-filter type="annotation"  expression="org.springframework.stereotype.Controller" /&amp;gt;
    &amp;lt;/context:component-scan&amp;gt;

    &amp;lt;!-- HandlerMapping, 无需配置， Spring MVC可以默认启动。 DefaultAnnotationHandlerMapping
        annotation-driven HandlerMapping --&amp;gt;

    &amp;lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&amp;gt;
    &amp;lt;mvc:annotation-driven /&amp;gt;


    &amp;lt;!-- 静态资源处理， css， js， imgs --&amp;gt;
    &amp;lt;mvc:resources mapping="/resources/**" location="/resources/" /&amp;gt;


    &amp;lt;!--&amp;lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;property name="alwaysUseFullPath" value="true"&amp;gt;&amp;lt;/property&amp;gt;--&amp;gt;
    &amp;lt;!--&amp;lt;/bean&amp;gt;--&amp;gt;

    &amp;lt;bean
            class="org.springframework.web.servlet.view.InternalResourceViewResolver"&amp;gt;
        &amp;lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&amp;gt;
        &amp;lt;property name="prefix" value="/WEB-INF/jsps/" /&amp;gt;
        &amp;lt;property name="suffix" value=".jsp" /&amp;gt;
    &amp;lt;/bean&amp;gt;





    &amp;lt;mvc:interceptors&amp;gt;
        &amp;lt;mvc:interceptor&amp;gt;
            &amp;lt;mvc:mapping path="/**"/&amp;gt;
            &amp;lt;bean class="com.happyBKs.interceptor.TestInterceptor"&amp;gt;&amp;lt;/bean&amp;gt;
        &amp;lt;/mvc:interceptor&amp;gt;
&amp;lt;!--        &amp;lt;mvc:interceptor&amp;gt;
            &amp;lt;mvc:mapping path="/**"/&amp;gt;
            &amp;lt;bean class="com.happyBKs.interceptor.TestInterceptor2"&amp;gt;&amp;lt;/bean&amp;gt;
        &amp;lt;/mvc:interceptor&amp;gt;--&amp;gt;
    &amp;lt;/mvc:interceptors&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;运行后请求http://localhost:8080/mvc/test2/login：&lt;/p&gt; 
&lt;p&gt;&lt;img height="123" src="http://static.oschina.net/uploads/space/2016/0712/222330_JZjN_1156339.png" width="623"/&gt;&lt;/p&gt; 
&lt;p&gt;提交后控制输出：无乱码&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-html"&gt;执行进入TestInterceptor的afterCompletion方法
197415 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet  - Successfully completed request
197415 [http-apr-8080-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet  - Successfully completed request
206359 [http-apr-8080-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet  - DispatcherServlet with name 'viewSpace-dispatcher' processing POST request for [/mvc/test2/viewAll]
206359 [http-apr-8080-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet  - DispatcherServlet with name 'viewSpace-dispatcher' processing POST request for [/mvc/test2/viewAll]
206360 [http-apr-8080-exec-1] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping  - Looking up handler method for path /viewAll
206360 [http-apr-8080-exec-1] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping  - Looking up handler method for path /viewAll
206360 [http-apr-8080-exec-1] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping  - Returning handler method [public org.springframework.web.servlet.ModelAndView com.happyBKs.controller.TestController2.viewAll(java.lang.String,java.lang.String)]
206360 [http-apr-8080-exec-1] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping  - Returning handler method [public org.springframework.web.servlet.ModelAndView com.happyBKs.controller.TestController2.viewAll(java.lang.String,java.lang.String)]
206360 [http-apr-8080-exec-1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory  - Returning cached instance of singleton bean 'testController2'
206360 [http-apr-8080-exec-1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory  - Returning cached instance of singleton bean 'testController2'
执行进入TestInterceptor的preHandle方法
206381 [http-apr-8080-exec-1] DEBUG org.springframework.web.cors.DefaultCorsProcessor  - Skip CORS processing: request is from same origin
206381 [http-apr-8080-exec-1] DEBUG org.springframework.web.cors.DefaultCorsProcessor  - Skip CORS processing: request is from same origin
进入控制器的viewAll方法...
name=马云
pwd=123
执行进入TestInterceptor的postHandle方法
206404 [http-apr-8080-exec-1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory  - Invoking afterPropertiesSet() on bean with name '/hello'
206404 [http-apr-8080-exec-1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory  - Invoking afterPropertiesSet() on bean with name '/hello'
206405 [http-apr-8080-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet  - Rendering view [org.springframework.web.servlet.view.JstlView: name '/hello'; URL [/WEB-INF/jsps//hello.jsp]] in DispatcherServlet with name 'viewSpace-dispatcher'
206405 [http-apr-8080-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet  - Rendering view [org.springframework.web.servlet.view.JstlView: name '/hello'; URL [/WEB-INF/jsps//hello.jsp]] in DispatcherServlet with name 'viewSpace-dispatcher'
206405 [http-apr-8080-exec-1] DEBUG org.springframework.web.servlet.view.JstlView  - Forwarding to resource [/WEB-INF/jsps//hello.jsp] in InternalResourceView '/hello'
206405 [http-apr-8080-exec-1] DEBUG org.springframework.web.servlet.view.JstlView  - Forwarding to resource [/WEB-INF/jsps//hello.jsp] in InternalResourceView '/hello'
执行进入TestInterceptor的afterCompletion方法&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;看到了吧，拦截器方法可以对请求的数据做很多设置和修改，同样，也可以对响应的数据的编码等做修改。&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#0000FF"&gt;&lt;strong&gt;2. 解决权限验证问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;比如，我们现在需要一个拦截器，专门用来做权限验证，拦截器会在preHandle方法检查服务服务器session是否有该用户的会话，如果有则继续执行，如果没有则将响应重定向到登录页面。&lt;/p&gt; 
&lt;p&gt;这个部分因为在大部分业务模块中都需要先行完成，如果把这样一个共性的东西添加到各个业务模块，整个系统的代码质量和可维护性可想而知有多糟，这正是拦截器的用武之地和使用原则。&lt;/p&gt; 
&lt;p&gt;好，我们就试着写个代码示例，在preHandle方法中：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;package com.happyBKs.interceptor;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Created by happyBKs on 2016/7/10.
 */
public class TestInterceptor implements HandlerInterceptor {
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("执行进入TestInterceptor的preHandle方法");
        request.setCharacterEncoding("utf-8");
        //对用户是否登录进行判断
        if(request.getSession().getAttribute("user")==null){
            //如果用户没有回话，即没有登录，就终止请求，并发送到登录页面
            request.getRequestDispatcher("/test2/login").forward(request,response);//发送到登录页面
            return false;//终止请求
        }
        return true;
    }

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("执行进入TestInterceptor的postHandle方法");
        //通过modelAndView参数改变显示的视图，或者修改发往视图的方法
//        modelAndView.addObject("msg","被拦截器的postHandle方法修改后的视图数据");
//        modelAndView.setViewName("/hello");

    }

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("执行进入TestInterceptor的afterCompletion方法");
    }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;好，我们尝试运行，并随便请求一个能给该拦截器拦截的url，如http://localhost:8080/mvc/test2/msg。这时候我们是没有登录过的，看看会发生什么。我们的预想是preHandle方法将验证到我们sessioin会话为空，然后跳转到登录页面。然而，恐怖的一幕发生了，页面死住，控制台开始疯狂套异常和死循环。。。&lt;/p&gt; 
&lt;p&gt;这是为什么呢？&lt;span style="color:#FF0000"&gt;原来，我们的登录页面url /test2/login也在拦截器的拦截返回内，当我们请求http://localhost:8080/mvc/test2/msg，拦截器preHandle方法检查到了我们会话为空没有登录，然后请求被终止的同时转而请求同样在拦截器作用返回内的/test2/login，这时候死循环的故事就开始了，懂了吧。因此，拦截器的使用需要十分留心，拦截器的方法中在对请求进行转发时尤为要注意，请求转发不能是该拦截器，否则就会出现死循环。当然，还有一种情况，就是多个拦截器作用下的多个url相互转发请求，造成多个拦截器之间的死循环。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;好，这里我们增加一个公共jsp页面\loginPub.jsp：页面内容不再详述&lt;/p&gt; 
&lt;p&gt;&lt;img height="131" src="http://static.oschina.net/uploads/space/2016/0712/224919_BsxB_1156339.png" width="197"/&gt;&lt;/p&gt; 
&lt;p&gt;拦截器代码改为：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;public class TestInterceptor implements HandlerInterceptor {
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("执行进入TestInterceptor的preHandle方法");
        request.setCharacterEncoding("utf-8");
        //对用户是否登录进行判断
        if(request.getSession().getAttribute("user")==null){
            //如果用户没有回话，即没有登录，就终止请求，并发送到登录页面
            //request.getRequestDispatcher("/test2/login").forward(request,response);//发送到登录页面
            request.getRequestDispatcher("/loginPub.jsp").forward(request,response);//发送到登录页面
            return false;//终止请求
        }
        return true;
    }&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;运行结果：&lt;/p&gt; 
&lt;p&gt;请求http://localhost:8080/mvc/test2/msg：&lt;/p&gt; 
&lt;p&gt;控制台输出显示，执行到了拦截器的preHandle方法之后就没有了，因为拦截器检测到没有登录，所以讲请求转发到了登录页面\loginPub.jsp&lt;/p&gt; 
&lt;p&gt;&lt;img height="244" src="http://static.oschina.net/uploads/space/2016/0712/224906_wBll_1156339.png" width="586"/&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="129" src="http://static.oschina.net/uploads/space/2016/0712/225157_AUz2_1156339.png" width="538"/&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt; &lt;/p&gt;                    &lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>mysql 几个常用函数
        -  书中迷梦的个人页面 - 开源中国社区</title><link>http://my.oschina.net/nixi0608/blog/710831</link><description>&lt;div class="BlogContent"&gt;
                    &lt;p&gt;1.IFNULL(value1,value2)&lt;/p&gt; 
&lt;p&gt;如果value1不为NULL那么返回value1,否则返回value2&lt;/p&gt; 
&lt;p&gt;&lt;img height="343" src="http://static.oschina.net/uploads/space/2016/0712/224236_y54X_1790478.png" width="450"/&gt;&lt;img height="328" src="http://static.oschina.net/uploads/space/2016/0712/224343_cXrh_1790478.png" width="529"/&gt;&lt;/p&gt; 
&lt;p&gt;2.IF(条件，value1,value2)&lt;/p&gt; 
&lt;p&gt;如果条件为true那么返回value1否则返回value2&lt;/p&gt; 
&lt;p&gt;&lt;img height="442" src="http://static.oschina.net/uploads/space/2016/0712/224605_N4oR_1790478.png" width="622"/&gt;&lt;/p&gt; 
&lt;p&gt;3.DATE(date)&lt;/p&gt; 
&lt;p&gt;返回日期&lt;/p&gt; 
&lt;p&gt;&lt;img height="354" src="http://static.oschina.net/uploads/space/2016/0712/224836_qXY9_1790478.png" width="520"/&gt;&lt;/p&gt; 
&lt;p&gt;4. CASE...WHEN&lt;/p&gt; 
&lt;p&gt; CASE oo.PAY_METHOD&lt;br/&gt;  WHEN '01' THEN   '现金'&lt;br/&gt;  WHEN '02' THEN   '刷卡'&lt;br/&gt;  WHEN '11' THEN   '银联'&lt;br/&gt;  WHEN '12' THEN   '网上银行'&lt;br/&gt;  WHEN '13' THEN   '微信'&lt;br/&gt;  WHEN '14' THEN   '支付宝'&lt;br/&gt;  WHEN '21' THEN   '金融支付'&lt;br/&gt;  END as "PAY_METHOD",  &amp;lt;!-- 支付方法(01-现金;02-刷卡;11-银联;12-网上银行) --&amp;gt;&lt;/p&gt;                    &lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>Num72  linux内外部命令，网络，开发环境搭建，常用命令
        -  萧筱
        的个人空间 - 开源中国社区</title><link>http://my.oschina.net/u/2356966/blog/710830</link><description>&lt;div class="BlogContent"&gt;
                    &lt;span id="OSC_h2_1"&gt;&lt;/span&gt;
&lt;h2&gt;内部外部命令&amp;amp;网络:&lt;/h2&gt; 
&lt;p&gt;&lt;img alt="" src="http://static.oschina.net/uploads/space/2016/0712/225105_ojdY_2356966.png"/&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_2"&gt;&lt;/span&gt;
&lt;h2&gt;linux开发环境搭建及yum工作原理:&lt;/h2&gt; 
&lt;p&gt;&lt;img alt="" height="1798" src="http://static.oschina.net/uploads/space/2016/0712/225124_68LX_2356966.png" width="1327"/&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt;
&lt;h2&gt;常用命令：&lt;/h2&gt; 
&lt;span id="OSC_h1_4"&gt;&lt;/span&gt;
&lt;h1&gt;1.         Linux命令&lt;/h1&gt; 
&lt;span id="OSC_h2_5"&gt;&lt;/span&gt;
&lt;h2&gt;1.1     Mkdir&lt;/h2&gt; 
&lt;p&gt;功能：创建目录&lt;/p&gt; 
&lt;p&gt;语法：mkdir dir…&lt;/p&gt; 
&lt;p&gt;命令：&lt;/p&gt; 
&lt;p&gt;1）  Mkdir dir&lt;/p&gt; 
&lt;p&gt;a)         创建dir目录。创建单个目录&lt;/p&gt; 
&lt;p&gt;2）  Mkdir dir1 dir2&lt;/p&gt; 
&lt;p&gt;a)         创建多个目录dir1 dir2&lt;/p&gt; 
&lt;p&gt;3）  mkdir dir{3..10}&lt;/p&gt; 
&lt;p&gt;a)         使用正则表达式创建3—10一共8个目录&lt;/p&gt; 
&lt;span id="OSC_h2_6"&gt;&lt;/span&gt;
&lt;h2&gt;1.2     Cp （copy）&lt;/h2&gt; 
&lt;p&gt;功能：复制文件和目录&lt;/p&gt; 
&lt;p&gt;语法：cp [OPTION]... SOURCE... DIRECTORY&lt;/p&gt; 
&lt;p&gt;复制文件：&lt;/p&gt; 
&lt;p&gt;命令：&lt;/p&gt; 
&lt;p&gt;1）  cp a.txt dir&lt;/p&gt; 
&lt;p&gt;a)         把a.txt拷贝到dir目录当中&lt;/p&gt; 
&lt;p&gt;2）  cp a.txt c.txt&lt;/p&gt; 
&lt;p&gt;a)         如果c.txt不存在，创建一个c.txt,内容一并拷贝过去。&lt;/p&gt; 
&lt;p&gt;b)        如果c.txt存在，内容会发生覆盖。&lt;/p&gt; 
&lt;p&gt;3）  cp *.txt dir1&lt;/p&gt; 
&lt;p&gt;a)         把当前目录所有txt文件复制到dir1目录&lt;/p&gt; 
&lt;p&gt;4）  cp a.txt b.txt c.txt dir2&lt;/p&gt; 
&lt;p&gt;a)         同时把多个文件复制到dir2目录&lt;/p&gt; 
&lt;p&gt;5）  cp dir1/* dir3&lt;/p&gt; 
&lt;p&gt;a)         把dir1目录下所有文件复制到dir3&lt;/p&gt; 
&lt;p&gt;复制目录：&lt;/p&gt; 
&lt;p&gt;1）  cp -r dir dir1&lt;/p&gt; 
&lt;p&gt;a)         复制单个目录dir到目录dir1&lt;/p&gt; 
&lt;p&gt;b)        –r：不能复制非空目录，必须进行递归复制。&lt;/p&gt; 
&lt;p&gt;2）  cp -r dir dir11&lt;/p&gt; 
&lt;p&gt;a)         如果dir11目录不存在，创建dir11，拷贝dir内容&lt;/p&gt; 
&lt;p&gt;b)        如果dir11存在，把dir目录拷贝dir11目录下面。&lt;/p&gt; 
&lt;p&gt;3）  cp -r dir1 dir2 dir3 dir4&lt;/p&gt; 
&lt;p&gt;a)         把目录dir1 dir2 dir3拷贝到目录dir4中&lt;/p&gt; 
&lt;p&gt;b)        注意：最后一个目录是目的目录。&lt;/p&gt; 
&lt;p&gt;4）  cp -r * dir&lt;/p&gt; 
&lt;p&gt;a)         把当前所有文件和目录拷贝到dir目录下&lt;/p&gt; 
&lt;p&gt;5）  cp -r dir* dir2&lt;/p&gt; 
&lt;p&gt;a)         拷贝所有以dir开头文件和目录到dir2目录中&lt;/p&gt; 
&lt;span id="OSC_h2_7"&gt;&lt;/span&gt;
&lt;h2&gt;1.3     Mv (move)&lt;/h2&gt; 
&lt;p&gt;功能：剪切&lt;/p&gt; 
&lt;p&gt;语法：mv [OPTION]... SOURCE... DIRECTORY&lt;/p&gt; 
&lt;p&gt;移动文件：&lt;/p&gt; 
&lt;p&gt;命令：&lt;/p&gt; 
&lt;p&gt;1）    mv file file1&lt;/p&gt; 
&lt;p&gt;a)         如果file1不存在，创建一个file1，内容复制。（重命名）&lt;/p&gt; 
&lt;p&gt;b)        如果file1存在，把file重命名为file1，内容进行覆盖。&lt;/p&gt; 
&lt;p&gt;2）    mv a.txt dir4&lt;/p&gt; 
&lt;p&gt;a)         把a.txt移动到dir4目录中&lt;/p&gt; 
&lt;p&gt;3）    mv *.txt dir5&lt;/p&gt; 
&lt;p&gt;a)         把所有以txt结尾文件移动到dir5目录&lt;/p&gt; 
&lt;p&gt;4）    mv dir/* dir5&lt;/p&gt; 
&lt;p&gt;a)         把dir目录下所有文件和目录移动到目录dir5&lt;/p&gt; 
&lt;p&gt;移动目录：&lt;/p&gt; 
&lt;p&gt;1）  mv dir dir12&lt;/p&gt; 
&lt;p&gt;a)         如果dir12不存在，把dir重命名为dir12&lt;/p&gt; 
&lt;p&gt;b)        如果dir12存在，把dir移动到dir12里面&lt;/p&gt; 
&lt;p&gt;2）  mv dir* dir2&lt;/p&gt; 
&lt;p&gt;a)         把当前目录所有以dir开头文件和目录移动到dir2中&lt;/p&gt; 
&lt;span id="OSC_h2_8"&gt;&lt;/span&gt;
&lt;h2&gt;1.4     Rm （remove）&lt;/h2&gt; 
&lt;p&gt;功能：删除&lt;/p&gt; 
&lt;p&gt;语法：rm [OPTION]... FILE...&lt;/p&gt; 
&lt;p&gt;命令：&lt;/p&gt; 
&lt;p&gt;删除文件：&lt;/p&gt; 
&lt;p&gt;1）  rm  b.txt&lt;/p&gt; 
&lt;p&gt;a)         提示删除b.txt&lt;/p&gt; 
&lt;p&gt;2）  rm -f c.txt&lt;/p&gt; 
&lt;p&gt;a)         强制删除c.txt&lt;/p&gt; 
&lt;p&gt;b)        –f:强制删除&lt;/p&gt; 
&lt;p&gt;3）  rm -f file1 file.txt&lt;/p&gt; 
&lt;p&gt;a)         同时删除多个文件&lt;/p&gt; 
&lt;p&gt;4）  rm -f file*&lt;/p&gt; 
&lt;p&gt;a)         删除所有以file开头文件&lt;/p&gt; 
&lt;p&gt;删除目录：&lt;/p&gt; 
&lt;p&gt;1）  rm -rf dir1&lt;/p&gt; 
&lt;p&gt;a)         删除单个目录dir1&lt;/p&gt; 
&lt;p&gt;b)        –f：强制删除，不提示&lt;/p&gt; 
&lt;p&gt;c)         –r：递归删除&lt;/p&gt; 
&lt;p&gt;2）  rm -rf dir2 dir3&lt;/p&gt; 
&lt;p&gt;a)         删除多个目录&lt;/p&gt; 
&lt;p&gt;3）  rm -rf *&lt;/p&gt; 
&lt;p&gt;a)         删除当前目录所有文件和目录&lt;/p&gt; 
&lt;p&gt;4）  rm -rf dir12/*&lt;/p&gt; 
&lt;p&gt;a)         删除指定目录dir12目录下所有文件和目录。&lt;/p&gt; 
&lt;p&gt;5）  rm -rf dir*&lt;/p&gt; 
&lt;span id="OSC_h2_9"&gt;&lt;/span&gt;
&lt;h2&gt;1.5     pwd&lt;/h2&gt; 
&lt;p&gt;功能：导航命令&lt;/p&gt; 
&lt;p&gt;语法：pwd&lt;/p&gt; 
&lt;p&gt;解析：显示当前目录所在位置&lt;/p&gt; 
&lt;span id="OSC_h2_10"&gt;&lt;/span&gt;
&lt;h2&gt;1.6     Cd&lt;/h2&gt; 
&lt;p&gt;功能：切换目录位置&lt;/p&gt; 
&lt;p&gt;语法：cd ~|dir|..&lt;/p&gt; 
&lt;p&gt;命令：&lt;/p&gt; 
&lt;p&gt;1）    cd ~&lt;/p&gt; 
&lt;p&gt;a)         调转到root目录&lt;/p&gt; 
&lt;p&gt;2）    cd ..&lt;/p&gt; 
&lt;p&gt;a)         跳转到上一级目录&lt;/p&gt; 
&lt;p&gt;3）    cd dir&lt;/p&gt; 
&lt;p&gt;a)         跳转当前目录dir目录下面。&lt;/p&gt; 
&lt;p&gt;4）    cd&lt;strong&gt; /dir&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;a)         跳转到当前目录以为的目录必须加&lt;strong&gt;/&lt;/strong&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_11"&gt;&lt;/span&gt;
&lt;h2&gt;1.7     Touch&lt;/h2&gt; 
&lt;p&gt;功能：创建文件&lt;/p&gt; 
&lt;p&gt;语法：touch 【-options】 file…&lt;/p&gt; 
&lt;p&gt;命令：&lt;/p&gt; 
&lt;p&gt;1）    touch file&lt;/p&gt; 
&lt;p&gt;a)         创建单个文件，文件名称为file&lt;/p&gt; 
&lt;p&gt;2）    touch file1 file2&lt;/p&gt; 
&lt;p&gt;a)         创建多个文件&lt;/p&gt; 
&lt;p&gt;3）    touch file{3..10}&lt;/p&gt; 
&lt;p&gt;a)         创建多个文件&lt;/p&gt; 
&lt;span id="OSC_h2_12"&gt;&lt;/span&gt;
&lt;h2&gt;1.8     Cat&lt;/h2&gt; 
&lt;p&gt;功能;查看文件&lt;/p&gt; 
&lt;p&gt;特点：查看文件全部内容。&lt;/p&gt; 
&lt;p&gt;适用场景：适合查看小文件内容。&lt;/p&gt; 
&lt;p&gt;语法：cat fileName&lt;/p&gt; 
&lt;span id="OSC_h2_13"&gt;&lt;/span&gt;
&lt;h2&gt;1.9     More&lt;/h2&gt; 
&lt;p&gt;功能：查询文件内容&lt;/p&gt; 
&lt;p&gt;特点：分页查询&lt;/p&gt; 
&lt;p&gt;语法：more fileName&lt;/p&gt; 
&lt;span id="OSC_h2_14"&gt;&lt;/span&gt;
&lt;h2&gt;1.10  Less&lt;/h2&gt; 
&lt;p&gt;功能：查询文件内容&lt;/p&gt; 
&lt;p&gt;特点：分页查询，上下翻页&lt;/p&gt; 
&lt;p&gt;语法：less fileName&lt;/p&gt; 
&lt;span id="OSC_h2_15"&gt;&lt;/span&gt;
&lt;h2&gt;1.11  Head&lt;/h2&gt; 
&lt;p&gt;功能：查询文件内容&lt;/p&gt; 
&lt;p&gt;特点：默认只显示文件头部10条数据&lt;/p&gt; 
&lt;span id="OSC_h2_16"&gt;&lt;/span&gt;
&lt;h2&gt;1.12  Tail&lt;/h2&gt; 
&lt;p&gt;功能：查询文件内容&lt;/p&gt; 
&lt;p&gt;特点：查看文件实时变化。&lt;/p&gt; 
&lt;p&gt;语法：tail –f fileName&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;span id="OSC_h2_17"&gt;&lt;/span&gt;
&lt;h2&gt;1.13  Top&lt;/h2&gt; 
&lt;p&gt;功能：查看当前系统资源占用情况&lt;/p&gt; 
&lt;p&gt;特点：默认每5秒刷新一次系统资源占用变化情况&lt;/p&gt; 
&lt;p&gt;语法：top&lt;/p&gt; 
&lt;p&gt;改变时间：top –d 2 每2秒刷新一次系统运行情况。&lt;/p&gt; 
&lt;span id="OSC_h2_18"&gt;&lt;/span&gt;
&lt;h2&gt;1.14  Ps&lt;/h2&gt; 
&lt;p&gt;功能：查看进程&lt;/p&gt; 
&lt;p&gt;语法：ps –ef&lt;/p&gt; 
&lt;span id="OSC_h2_19"&gt;&lt;/span&gt;
&lt;h2&gt;1.15  Kill&lt;/h2&gt; 
&lt;p&gt;功能：杀死进程&lt;/p&gt; 
&lt;p&gt;语法：kill -9 PID&lt;/p&gt; 
&lt;span id="OSC_h2_20"&gt;&lt;/span&gt;
&lt;h2&gt;1.16  Df&lt;/h2&gt; 
&lt;p&gt;功能：显示当前磁盘资源使用情况&lt;/p&gt; 
&lt;p&gt;语法：df&lt;/p&gt; 
&lt;p&gt;单位显示：df –h&lt;/p&gt; 
&lt;span id="OSC_h2_21"&gt;&lt;/span&gt;
&lt;h2&gt;1.17  Which&lt;/h2&gt; 
&lt;p&gt;功能：查询命令：查询命令别名，命令所在位置&lt;/p&gt; 
&lt;p&gt;语法：which + 命令名称&lt;/p&gt; 
&lt;span id="OSC_h2_22"&gt;&lt;/span&gt;
&lt;h2&gt;1.18  Whereis&lt;/h2&gt; 
&lt;p&gt;功能：查询命令&lt;/p&gt; 
&lt;p&gt;特点：查询命令位置，查询命令源码，查询命令帮助文档。&lt;/p&gt; 
&lt;p&gt;语法：whereis +命令名称&lt;/p&gt; 
&lt;span id="OSC_h2_23"&gt;&lt;/span&gt;
&lt;h2&gt;1.19  Locate&lt;/h2&gt; 
&lt;p&gt;功能：查询文件&lt;/p&gt; 
&lt;p&gt;语法：locate fileName&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;span id="OSC_h2_24"&gt;&lt;/span&gt;
&lt;h2&gt;1.20  Find&lt;/h2&gt; 
&lt;p&gt;功能：查找文件&lt;/p&gt; 
&lt;p&gt;语法：&lt;strong&gt;find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;命令：&lt;/p&gt; 
&lt;p&gt;1）  find -name file2&lt;/p&gt; 
&lt;p&gt;a)         根据文件名称查询文件，查询文件名为file2文件&lt;/p&gt; 
&lt;p&gt;b)        –name:根据文件名称查询&lt;/p&gt; 
&lt;p&gt;2）  find -name "file2"&lt;/p&gt; 
&lt;p&gt;a)         根据文件名称查询文件，查询文件名为file2文件：&lt;/p&gt; 
&lt;p&gt;b)        一般使用加引号进行查询：如果使用复杂查询表达式，加引号才能识别。&lt;/p&gt; 
&lt;p&gt;3）  find /etc/ -name "[A-Z]*"&lt;/p&gt; 
&lt;p&gt;a)         查询etc目录下所有以大写字母A-Z开头的所有文件。&lt;/p&gt; 
&lt;p&gt;4）  find /etc/ -name "[A-Z]*" -exec ls -l {} \;&lt;/p&gt; 
&lt;p&gt;a)         查询etc目录下所有大写字母A-Z开头的文件，显示这些文件详细信息。&lt;/p&gt; 
&lt;p&gt;b)        –exec：执行，把前面命令查询结果交给后面命令执行。&lt;/p&gt; 
&lt;p&gt;c)         {}:表示查询结果在一行进行显示。&lt;/p&gt; 
&lt;p&gt;d)        \；:命令以分号结束，斜杠转义分号。&lt;/p&gt; 
&lt;span id="OSC_h2_25"&gt;&lt;/span&gt;
&lt;h2&gt;1.21  | （管道命令）&lt;/h2&gt; 
&lt;p&gt;功能：把前面命令执行结果交给后面命令进行执行。&lt;/p&gt; 
&lt;p&gt;应用场景：svn进程，mysql进程&lt;/p&gt; 
&lt;p&gt;语法：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Ls –al | more -5&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;span id="OSC_h2_26"&gt;&lt;/span&gt;
&lt;h2&gt;1.22  Grep&lt;/h2&gt; 
&lt;p&gt;功能：过滤查询&lt;/p&gt; 
&lt;p&gt;应用场景：结合管道命令进行使用。&lt;/p&gt; 
&lt;p&gt;命令：&lt;/p&gt; 
&lt;p&gt;语法：find /etc/ -name "[A-Z]*" | grep FileName&lt;/p&gt; 
&lt;p&gt;find /etc/ -name "[A-Z]*" | grep README&lt;/p&gt; 
&lt;p&gt;Ps –ef | grep svn&lt;/p&gt; 
&lt;p&gt;Ps –ef | grep mysql&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;span id="OSC_h2_27"&gt;&lt;/span&gt;
&lt;h2&gt;1.23  Ln&lt;/h2&gt; 
&lt;p&gt;功能：创建快捷方式&lt;/p&gt; 
&lt;p&gt;命令：ln –s filename link（快捷方式名称，自定义）&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;span id="OSC_h1_28"&gt;&lt;/span&gt;
&lt;h1&gt;2.         解压缩命令&lt;/h1&gt; 
&lt;span id="OSC_h2_29"&gt;&lt;/span&gt;
&lt;h2&gt;2.1     Gzip&lt;/h2&gt; 
&lt;p&gt;功能：使用gzip算法把文件进行压缩，解压。&lt;/p&gt; 
&lt;p&gt;压缩语法：gzip filename…&lt;/p&gt; 
&lt;p&gt;解压语法：gunzip file.gz….        Gzip –dv filename.gz…&lt;/p&gt; 
&lt;p&gt;命令：&lt;/p&gt; 
&lt;p&gt;1）    gzip file&lt;/p&gt; 
&lt;p&gt;a)         压缩单个文件file文件，file.gz&lt;/p&gt; 
&lt;p&gt;2）    gzip file2 file3&lt;/p&gt; 
&lt;p&gt;a)         压缩多个文件&lt;/p&gt; 
&lt;p&gt;3）    gzip file*&lt;/p&gt; 
&lt;p&gt;a)         压缩所有以file开头文件&lt;/p&gt; 
&lt;p&gt;解压：&lt;/p&gt; 
&lt;p&gt;1）    gunzip file.gz&lt;/p&gt; 
&lt;p&gt;a)         解压单个文件file.gz&lt;/p&gt; 
&lt;p&gt;2）    gunzip file*&lt;/p&gt; 
&lt;p&gt;a)         解压所有以file开头压缩文件&lt;/p&gt; 
&lt;p&gt;3）    gzip -dv file*&lt;/p&gt; 
&lt;p&gt;a)         解压所有以file开头压缩文件&lt;/p&gt; 
&lt;p&gt;b)        –d：解压文件&lt;/p&gt; 
&lt;p&gt;c)         –v：显示解压过程&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;span id="OSC_h2_30"&gt;&lt;/span&gt;
&lt;h2&gt;2.2     Bzip2&lt;/h2&gt; 
&lt;p&gt;功能：使用bzip2算法把文件进行压缩，解压。&lt;/p&gt; 
&lt;p&gt;压缩语法：bzip2 filename…&lt;/p&gt; 
&lt;p&gt;解压语法：bunzip2 file.gz….        bzip2 –dv filename.gz…&lt;/p&gt; 
&lt;p&gt;命令：&lt;/p&gt; 
&lt;p&gt;4）    bzip2 file&lt;/p&gt; 
&lt;p&gt;a)         压缩单个文件file文件，file.bz2&lt;/p&gt; 
&lt;p&gt;5）    bzip2 file2 file3&lt;/p&gt; 
&lt;p&gt;a)         压缩多个文件&lt;/p&gt; 
&lt;p&gt;6）    bzip2 file*&lt;/p&gt; 
&lt;p&gt;a)         压缩所有以file开头文件&lt;/p&gt; 
&lt;p&gt;解压：&lt;/p&gt; 
&lt;p&gt;4）    bunzip2  file.gz&lt;/p&gt; 
&lt;p&gt;a)         解压单个文件file.gz&lt;/p&gt; 
&lt;p&gt;5）    bunzip2  file*&lt;/p&gt; 
&lt;p&gt;a)         解压所有以file开头压缩文件&lt;/p&gt; 
&lt;p&gt;6）    bzip2 -dv file*&lt;/p&gt; 
&lt;p&gt;a)         解压所有以file开头压缩文件&lt;/p&gt; 
&lt;p&gt;b)        –d：解压文件&lt;/p&gt; 
&lt;p&gt;c)         –v：显示解压过程&lt;/p&gt; 
&lt;span id="OSC_h2_31"&gt;&lt;/span&gt;
&lt;h2&gt;2.3     Zip&lt;/h2&gt; 
&lt;p&gt;功能：使用zip算法压缩文件，解压文件&lt;/p&gt; 
&lt;p&gt;语法：zip myzip.zip filename  (myzip.zip是自己指定文件名称) filename指定需要压缩文件&lt;/p&gt; 
&lt;p&gt;命令：&lt;/p&gt; 
&lt;p&gt;1）    zip myzip.zip file&lt;/p&gt; 
&lt;p&gt;a)         把文件file压缩成myzip.zip文件&lt;/p&gt; 
&lt;p&gt;2）    Zip myzip.zip file*&lt;/p&gt; 
&lt;p&gt;a)         把所有以file开头文件压缩成myzip.zip文件&lt;/p&gt; 
&lt;p&gt;3）    解压：&lt;/p&gt; 
&lt;p&gt;a)         unzip myzip.zip&lt;/p&gt; 
&lt;span id="OSC_h2_32"&gt;&lt;/span&gt;
&lt;h2&gt;2.4     tar&lt;/h2&gt; 
&lt;p&gt;功能：打包，把文件和文件夹打包，打包后文件扩展名.tar&lt;/p&gt; 
&lt;p&gt;应用场景：tar命令结合压缩命令进行使用，先打包，然后再压缩，实现了压缩命令间接压缩目录。&lt;/p&gt; 
&lt;p&gt;语法：&lt;/p&gt; 
&lt;p&gt;打包命令：tar –cvf mytar.tar dir…&lt;/p&gt; 
&lt;p&gt;解包命令：tar –xvf mytar.tar&lt;/p&gt; 
&lt;p&gt;命令：&lt;/p&gt; 
&lt;p&gt;1）  tar -cvf mytar.tar dir12&lt;/p&gt; 
&lt;p&gt;a)         把dir12目录打包mytar.tar文件&lt;/p&gt; 
&lt;p&gt;b)        –c：打包&lt;/p&gt; 
&lt;p&gt;c)         –v：显示打包过程&lt;/p&gt; 
&lt;p&gt;d)        –f：指定打包文件&lt;/p&gt; 
&lt;p&gt;2）  tar –xvf mytar.tar&lt;/p&gt; 
&lt;p&gt;a)         –x:解包&lt;/p&gt; 
&lt;p&gt;b)        –v：显示解包过程&lt;/p&gt; 
&lt;p&gt;c)         –f：指定解包文件&lt;/p&gt; 
&lt;p&gt;使用tar命令解压tar.gz文件：&lt;/p&gt; 
&lt;p&gt;1）  &lt;strong&gt;tar –zxvf mytar.tar.gz &lt;/strong&gt; （解压使用gzip压缩文件）&lt;/p&gt; 
&lt;p&gt;a)         解压使用gzip压缩tar包&lt;/p&gt; 
&lt;p&gt;b)        –z：解压使用gzip压缩gz包&lt;/p&gt; 
&lt;p&gt;c)         –x：解包tar&lt;/p&gt; 
&lt;p&gt;d)        –v：显示解压过程&lt;/p&gt; 
&lt;p&gt;e)         –f：指定解压文件&lt;/p&gt; 
&lt;p&gt;2）  tar -jxvf mybzip2.tar.bz2&lt;/p&gt; 
&lt;p&gt;a)         解压使用bzip2压缩tar包&lt;/p&gt; 
&lt;p&gt;b)        –j：解压使用bzip2压缩bz2包&lt;/p&gt; 
&lt;p&gt;c)         –x：解包tar&lt;/p&gt; 
&lt;p&gt;d)        –v：显示解压过程&lt;/p&gt; 
&lt;p&gt;e)         –f：指定解压文件&lt;/p&gt; 
&lt;span id="OSC_h1_33"&gt;&lt;/span&gt;
&lt;h1&gt;3.         vim编辑器&lt;/h1&gt; 
&lt;p&gt;功能：对文件进行编辑，使用vim命令进入文件编辑模型。&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;vi有3个模式：插入模式、命令模式、低行模式。&lt;/p&gt; 
&lt;p&gt;插入模式：在此模式下可以输入字符，按ESC将回到命令模式。&lt;br/&gt; 命令模式：可以移动光标、删除字符等。&lt;br/&gt; 低行模式：可以保存文件、退出vi、设置vi、查找等功能(低行模式也可以看作是命令模式里的)。&lt;/p&gt; 
&lt;span id="OSC_h2_34"&gt;&lt;/span&gt;
&lt;h2&gt;3.1     打开文件、保存、关闭文件(vi命令模式下使用)&lt;/h2&gt; 
&lt;p&gt;vi filename       //打开filename文件&lt;br/&gt; :w       //保存文件&lt;br/&gt; :w vpser.net //保存至vpser.net文件&lt;br/&gt; :q          //退出编辑器，如果文件已修改请使用下面的命令&lt;br/&gt; :q!        //退出编辑器，且不保存&lt;br/&gt; :wq         //退出编辑器，且保存文件&lt;/p&gt; 
&lt;p&gt;使用快捷键进行保存：shift+ZZ&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;span id="OSC_h2_35"&gt;&lt;/span&gt;
&lt;h2&gt;3.2     插入文本或行(vi命令模式下使用，执行下面命令后将进入插入模式，按ESC键可退出插入模式)&lt;/h2&gt; 
&lt;p&gt;a      //在当前光标位置的右边添加文本&lt;br/&gt; i       //在当前光标位置的左边添加文本&lt;br/&gt; A     //在当前行的末尾位置添加文本&lt;br/&gt; I      //在当前行的开始处添加文本(非空字符的行首)&lt;br/&gt; O     //在当前行的上面新建一行&lt;br/&gt; o     //在当前行的下面新建一行&lt;br/&gt; R    //替换(覆盖)当前光标位置及后面的若干文本&lt;br/&gt; J    //合并光标所在行及下一行为一行(依然在命令模式)&lt;/p&gt; 
&lt;span id="OSC_h3_36"&gt;&lt;/span&gt;
&lt;h3&gt;&lt;strong&gt;3.2.1              &lt;/strong&gt;移动光标(vi命令模式下使用)&lt;/h3&gt; 
&lt;p&gt;1、使用上下左右方向键&lt;/p&gt; 
&lt;p&gt;2、命令模式下：h   向左、j   向下 、k   向上、l  向右。&lt;br/&gt; 空格键 向右、Backspace  向左、Enter  移动到下一行首、-  移动到上一行首。&lt;/p&gt; 
&lt;span id="OSC_h2_37"&gt;&lt;/span&gt;
&lt;h2&gt;3.3     删除、恢复字符或行(vi命令模式下使用)&lt;/h2&gt; 
&lt;p&gt;x         //删除当前字符&lt;br/&gt; nx         //删除从光标开始的n个字符&lt;br/&gt; dd      //删除当前行&lt;br/&gt; ndd   //向下删除当前行在内的n行&lt;br/&gt; u       //撤销上一步操作&lt;br/&gt; U      //撤销对当前行的所有操作&lt;/p&gt; 
&lt;span id="OSC_h2_38"&gt;&lt;/span&gt;
&lt;h2&gt;3.4     搜索(vi命令模式下使用)&lt;/h2&gt; 
&lt;p&gt;/vpser     //向光标下搜索vpser字符串&lt;br/&gt; ?vpser     //向光标上搜索vpser字符串&lt;br/&gt; n           //向下搜索前一个搜素动作&lt;br/&gt; N         //向上搜索前一个搜索动作&lt;/p&gt; 
&lt;span id="OSC_h2_39"&gt;&lt;/span&gt;
&lt;h2&gt;3.5     跳至指定行(vi命令模式下使用)&lt;/h2&gt; 
&lt;p&gt;n+        //向下跳n行&lt;br/&gt; n-         //向上跳n行&lt;br/&gt; nG        //跳到行号为n的行&lt;br/&gt; G         //跳至文件的底部&lt;/p&gt; 
&lt;span id="OSC_h2_40"&gt;&lt;/span&gt;
&lt;h2&gt;3.6     设置行号(vi命令模式下使用)&lt;/h2&gt; 
&lt;p&gt;:set  nu     //显示行号&lt;br/&gt; :set nonu    //取消显示行号&lt;/p&gt; 
&lt;span id="OSC_h2_41"&gt;&lt;/span&gt;
&lt;h2&gt;3.7     复制、粘贴(vi命令模式下使用)&lt;/h2&gt; 
&lt;p&gt;yy    //将当前行复制到缓存区，也可以用 "ayy 复制，"a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。&lt;br/&gt; nyy   //将当前行向下n行复制到缓冲区，也可以用 "anyy 复制，"a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。&lt;br/&gt; yw    //复制从光标开始到词尾的字符。&lt;br/&gt; nyw   //复制从光标开始的n个单词。&lt;br/&gt; y^      //复制从光标到行首的内容。  &lt;a href="http://www.vpser.net/" rel="nofollow"&gt;VPS侦探&lt;/a&gt;&lt;br/&gt; y$      //复制从光标到行尾的内容。&lt;br/&gt; p        //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用"ap 进行粘贴。&lt;br/&gt; P        //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用"aP 进行粘贴。&lt;/p&gt; 
&lt;span id="OSC_h2_42"&gt;&lt;/span&gt;
&lt;h2&gt;3.8     替换(vi命令模式下使用)&lt;/h2&gt; 
&lt;p&gt;:s/old/new      //用new替换&lt;strong&gt;行中&lt;/strong&gt;首次出现的old&lt;br/&gt; :s/old/new/g         //用new替换行中所有的old&lt;br/&gt; :n,m s/old/new/g     //用new替换从n到m行里所有的old&lt;br/&gt; :%s/old/new/g      //用new替换当前文件里所有的old&lt;/p&gt; 
&lt;span id="OSC_h1_43"&gt;&lt;/span&gt;
&lt;h1&gt;4.         用户和组账户管理&lt;/h1&gt; 
&lt;p&gt;linux操作系统是一个多用户操作系统，它允许多用户同时登录到系统上并使用资源。系统会根据账户来区分每个用户的文件，进程，任务和工作环境，使得每个用户工作都不受干扰&lt;/p&gt; 
&lt;span id="OSC_h2_44"&gt;&lt;/span&gt;
&lt;h2&gt;4.1     一个标准用户有哪些配置文件?&lt;/h2&gt; 
&lt;p&gt;保存用户信息的文件：/etc/passwd&lt;/p&gt; 
&lt;p&gt;文件字段：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell&lt;/p&gt; 
&lt;p&gt;关于/etc/passwd 和 UID:&lt;/p&gt; 
&lt;p&gt;    /etc/passwd 是系统识别用户的一个文件，做个不恰当的比喻，/etc/passwd 是一个花名册，系统所有的用户都在这里有登录记载；当我们以beinan 这个账号登录时，系统首先会查阅 /etc/passwd 文件，看是否有beinan 这个账号，然后确定beinan的UID，通过UID 来确认用户和身份，如果存在则读取/etc/shadow 影子文件中所对应的beinan的密码；如果密码核实无误则登录系统，读取用户的配置文件；   &lt;/p&gt; 
&lt;p&gt;保存密码的文件：/etc/shadow&lt;/p&gt; 
&lt;p&gt;查看命令：man 5 shadow&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;保存用户组的文件：/etc/group&lt;/p&gt; 
&lt;p&gt;保存用户组密码的文件：/etc/gshadow&lt;/p&gt; 
&lt;p&gt;用户配置文件：&lt;/p&gt; 
&lt;p&gt;/etc/default/useradd&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;useradd&lt;/strong&gt;&lt;strong&gt;详细信息：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;/etc/login.defs&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;lonin.defs&lt;/strong&gt;&lt;strong&gt;详细信息&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;使用命令：man 5 passwd&lt;/p&gt; 
&lt;p&gt;account:password:UID:GID:GECOS:directory:shell&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;span id="OSC_h2_45"&gt;&lt;/span&gt;
&lt;h2&gt;4.2     Linux用户分类&lt;/h2&gt; 
&lt;p&gt;超级用户：（root，UID=0）&lt;/p&gt; 
&lt;p&gt;普通用户：（UID在500到60000）&lt;/p&gt; 
&lt;p&gt;伪用户：（UID在1到499）&lt;/p&gt; 
&lt;p&gt;系统和服务相关的：bin、daemon、shutdown等&lt;/p&gt; 
&lt;p&gt;进程相关的：mail、news、games等&lt;/p&gt; 
&lt;p&gt;伪用户不能登陆系统，而且没有宿主目录&lt;/p&gt; 
&lt;span id="OSC_h2_46"&gt;&lt;/span&gt;
&lt;h2&gt;4.3     操作用户命令&lt;/h2&gt; 
&lt;span id="OSC_h3_47"&gt;&lt;/span&gt;
&lt;h3&gt;&lt;strong&gt;4.3.1              &lt;/strong&gt;添加用户(useradd)&lt;/h3&gt; 
&lt;p&gt;添加用户命令：useradd [-选项] 用户名&lt;/p&gt; 
&lt;p&gt;-u 指定用户ID（uid）&lt;/p&gt; 
&lt;p&gt;-g 指定所属的组名（gid）&lt;/p&gt; 
&lt;p&gt;-G 指定多个组，用逗号“，”分开（Groups）&lt;/p&gt; 
&lt;p&gt;-c 用户描述（comment）&lt;/p&gt; 
&lt;p&gt;-e 失效时间（expire date）&lt;/p&gt; 
&lt;p&gt;例子：&lt;/p&gt; 
&lt;p&gt;useradd -u 888 -g users -G sys,root -c "itcast" itcast&lt;/p&gt; 
&lt;p&gt;passwd itcast&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;实例1&lt;/strong&gt;&lt;strong&gt;：创建一个用户&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;&lt;strong&gt;命令：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;useradd mine&lt;/p&gt; 
&lt;p&gt;    创建一个用户名是mine的用户。这个用户没有任何密码&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;       vim /etc/shadow&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;&lt;strong&gt;查看用户：发现mine&lt;/strong&gt;&lt;strong&gt;用户创建成功，但是没有密码&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;设置mine&lt;/strong&gt;&lt;strong&gt;用户的密码：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;这样密码更新成功&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;注意：也可以直接指定用户密码进行创建用户。命令在上面已经指出，大家下去自己练习&lt;/strong&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_48"&gt;&lt;/span&gt;
&lt;h3&gt;&lt;strong&gt;4.3.2              &lt;/strong&gt;更新用户(usermod)&lt;/h3&gt; 
&lt;p&gt;修改用户命令：usermod（user modify）&lt;/p&gt; 
&lt;p&gt;-l 修改用户名 （login）usermod -l a b（b改为a）&lt;/p&gt; 
&lt;p&gt;-g 添加组 usermod -g sys&lt;/p&gt; 
&lt;p&gt;-G添加多个组 usermod -G sys,root tom&lt;/p&gt; 
&lt;p&gt;–L 锁定用户账号密码（Lock）&lt;/p&gt; 
&lt;p&gt;–U 解锁用户账号（Unlock）&lt;/p&gt; 
&lt;span id="OSC_h3_49"&gt;&lt;/span&gt;
&lt;h3&gt;&lt;strong&gt;4.3.3              &lt;/strong&gt;删除用户(userdel)&lt;/h3&gt; 
&lt;p&gt;删除用户命令：userdel（user delete）&lt;/p&gt; 
&lt;p&gt;-r 删除账号时同时删除目录（remove）&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;span id="OSC_h2_50"&gt;&lt;/span&gt;
&lt;h2&gt;4.4     操作用户组命令&lt;/h2&gt; 
&lt;span id="OSC_h3_51"&gt;&lt;/span&gt;
&lt;h3&gt;&lt;strong&gt;4.4.1              &lt;/strong&gt;添加组(goupadd)&lt;/h3&gt; 
&lt;p&gt;添加组：groupadd&lt;/p&gt; 
&lt;p&gt;-g 指定gid&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;span id="OSC_h3_52"&gt;&lt;/span&gt;
&lt;h3&gt;&lt;strong&gt;4.4.2              &lt;/strong&gt;修改组(groupmod)&lt;/h3&gt; 
&lt;p&gt;修改组：groupmod&lt;/p&gt; 
&lt;p&gt;-n 更改组名（new group）&lt;/p&gt; 
&lt;span id="OSC_h3_53"&gt;&lt;/span&gt;
&lt;h3&gt;&lt;strong&gt;4.4.3              &lt;/strong&gt;删除组(groupdel)&lt;/h3&gt; 
&lt;p&gt;删除组：groupdel&lt;/p&gt; 
&lt;p&gt;groups 显示用户所属组&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;span id="OSC_h1_54"&gt;&lt;/span&gt;
&lt;h1&gt;5.         权限&lt;/h1&gt; 
&lt;span id="OSC_h2_55"&gt;&lt;/span&gt;
&lt;h2&gt;5.1     第一种方式&lt;/h2&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;span id="OSC_h2_56"&gt;&lt;/span&gt;
&lt;h2&gt;5.2     第二种方式&lt;/h2&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;span id="OSC_h1_57"&gt;&lt;/span&gt;
&lt;h1&gt;6.         安装软件&lt;/h1&gt; 
&lt;span id="OSC_h2_58"&gt;&lt;/span&gt;
&lt;h2&gt;6.1     Rpm&lt;/h2&gt; 
&lt;p&gt;rpm的常用参数&lt;/p&gt; 
&lt;p&gt;i：安装应用程序（install）&lt;/p&gt; 
&lt;p&gt;e：卸载应用程序（erase）&lt;/p&gt; 
&lt;p&gt;vh：显示安装进度；（verbose   hash）&lt;/p&gt; 
&lt;p&gt;U：升级软件包；（update）&lt;/p&gt; 
&lt;p&gt;qa: 显示所有已安装软件包（query all）&lt;/p&gt; 
&lt;p&gt;结合grep命令使用&lt;/p&gt; 
&lt;p&gt;例子：rmp  -ivh  gcc-c++-4.4.7-3.el6.x86_64.rpm&lt;/p&gt;                    &lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>『Data Science』R语言学习笔记，使用Swirl包学习R
        -  背着幸福的灰大羊 - 开源中国社区</title><link>http://my.oschina.net/skyler/blog/710826</link><description>&lt;div class="BlogContent"&gt;&lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>判断字符长度
        -  小蟲
        的个人空间 - 开源中国社区</title><link>http://my.oschina.net/u/2408700/blog/710824</link><description>&lt;div class="BlogContent"&gt;
                    &lt;p&gt;判断字符长度&lt;/p&gt; 
&lt;p&gt;strlen与mb_strlen判断字符串是纯英文/纯汉字/汉英混合,在php中UTF8每个汉字等于3个长度； GBK每个汉字等于2个长度；&lt;/p&gt;                    &lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>ssh 协议
        -  __K__ - 开源中国社区</title><link>http://my.oschina.net/lowkey2046/blog/710823</link><description>&lt;div class="BlogContent"&gt;&lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>Java中的集合
        -  西红柿的眼泪的个人页面 - 开源中国社区</title><link>http://my.oschina.net/zkctt/blog/710815</link><description>&lt;div class="BlogContent"&gt;
                    &lt;p&gt;java集合类是一种的特别有用的工具类，可用来存储数量不等的对象，并可以实现常用的数据结构，如栈、队列等。除此之外，Java集合还可用于保存具有映射关系的关联数组。java集合大致可分为Set、List、Queue和Map四种体系，其中Set代表无序，不可重复的集合；List代表有序、重复的集合；而Map则代表映射关系的集合；java5又增加的Queue体系集合代表一种队列集合的实现。&lt;/p&gt; 
&lt;p&gt;Java的集合类主要有两个接口派生而出：Collection和Map，Collection和Map是java集合框架的根接口。Collection派生出来Set和List还有Queue接口都是有Collection接口派生的两个子接口。Map体系的继承树，所有的Map实现类用于保存具有映射关系的数据。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" height="378" src="http://static.oschina.net/uploads/space/2016/0712/221945_RVa4_2603195.jpg" width="1024"/&gt;&lt;/p&gt;                    &lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>数组迭代方法之reduce
        -  tv_哇的个人空间 - 开源中国社区</title><link>http://my.oschina.net/tvwawawa/blog/710812</link><description>&lt;div class="BlogContent"&gt;&lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>view.findViewById和findViewById的区别
        -  路人丁语 - 开源中国社区</title><link>http://my.oschina.net/5icode/blog/710807</link><description>&lt;div class="BlogContent"&gt;&lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>依赖
        -  小真真的个人页面 - 开源中国社区</title><link>http://my.oschina.net/dtz/blog/710804</link><description>&lt;div class="BlogContent"&gt;
                    &lt;span id="OSC_h2_1"&gt;&lt;/span&gt;
&lt;h2&gt;1. 依赖&lt;/h2&gt; 
&lt;p&gt;典型的企业应用不会只由单一的对象（或Spring的术语bean)组成。毫无疑问，即使最简单的系统也需要多个对象共同来展示给用户一个整体的应用。接下来的的内容除了阐述如何单独定义一系列bean外，还将描述如何让这些bean对象一起协同工作来实现一个完整的真实应用。&lt;/p&gt; 
&lt;span id="OSC_h3_2"&gt;&lt;/span&gt;
&lt;h3&gt;1. 注入依赖&lt;/h3&gt; 
&lt;p&gt;&lt;em&gt;依赖注入&lt;/em&gt;（DI）背后的基本原理是对象之间的依赖关系（即一起工作的其它对象）只会通过以下几种方式来实现：构造器的参数、工厂方法的参数，或给由构造函数或者工厂方法创建的对象设置属性。因此，容器的工作就是创建bean时&lt;em&gt;注入&lt;/em&gt;那些依赖关系。相对于由bean自己来控制其实例化、直接在构造器中指定依赖关系或者类似&lt;em&gt;服务定位器（Service Locator）&lt;/em&gt;模式这3种自主控制依赖关系注入的方法来说，控制从根本上发生了倒转，这也正是&lt;em&gt;控制反转（Inversion of Control， IoC）&lt;/em&gt; 名字的由来。&lt;/p&gt; 
&lt;p&gt;应用DI原则后，代码将更加清晰。而且当bean自己不再担心对象之间的依赖关系（甚至不知道依赖的定义指定地方和依赖的实际类）之后，实现更高层次的松耦合将易如反掌。DI主要有两种注入方式，即&lt;a rel="nofollow"&gt;Setter注入&lt;/a&gt;和&lt;a rel="nofollow"&gt;构造器注入&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;。&lt;/p&gt; 
&lt;span id="OSC_h4_3"&gt;&lt;/span&gt;
&lt;h4&gt;1.1. 构造器注入&lt;/h4&gt; 
&lt;p&gt;&lt;em&gt;基于构造器&lt;/em&gt;的DI通过调用带参数的构造器来实现，每个参数代表着一个依赖。此外，还可通过给&lt;code&gt;stattic&lt;/code&gt;工厂方法传参数来构造bean。接下来的介绍将认为给构造器传参与给&lt;code&gt;静态&lt;/code&gt;工厂方法传参是类似的。下面展示了只能使用构造器参数来注入依赖关系的例子。请注意，这个类并没有什么&lt;em&gt;特别之处&lt;/em&gt;。&lt;/p&gt; 
&lt;pre&gt;public class SimpleMovieLister {

    &lt;em&gt;// the &lt;code&gt;SimpleMovieLister&lt;/code&gt; has a dependency on a &lt;code&gt;MovieFinder&lt;/code&gt;&lt;/em&gt;
    private MovieFinder movieFinder;

    &lt;em&gt;// a constructor so that the Spring container can 'inject' a &lt;code&gt;MovieFinder&lt;/code&gt;&lt;/em&gt;
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
    
    &lt;em&gt;// business logic that actually 'uses' the injected &lt;code&gt;MovieFinder&lt;/code&gt; is omitted...&lt;/em&gt;
}&lt;/pre&gt; 
&lt;span id="OSC_h5_4"&gt;&lt;/span&gt;
&lt;h5&gt;1.1.1. 构造器参数解析&lt;/h5&gt; 
&lt;p&gt;构造器参数解析根据参数类型进行匹配，如果bean的构造器参数类型定义非常明确，那么在bean被实例化的时候，bean定义中构造器参数的定义顺序就是这些参数的顺序，依次进行匹配，比如下面的代码&lt;/p&gt; 
&lt;pre&gt;package x.y;

public class Foo {

    public Foo(Bar bar, Baz baz) {
        &lt;em&gt;// ...&lt;/em&gt;
    }
}&lt;/pre&gt; 
&lt;p&gt;上述例子中由于构造参数非常明确（这里我们假定 &lt;code&gt;Bar&lt;/code&gt;和 &lt;code&gt;Baz&lt;/code&gt;之间不存在继承关系）。因此下面的配置即使没有明确指定构造参数顺序（和类型），也会工作的很好。&lt;/p&gt; 
&lt;pre&gt;&amp;lt;beans&amp;gt;
    &amp;lt;bean name="foo" class="x.y.Foo"&amp;gt;
        &amp;lt;constructor-arg&amp;gt;
            &amp;lt;bean class="x.y.Bar"/&amp;gt;
        &amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg&amp;gt;
            &amp;lt;bean class="x.y.Baz"/&amp;gt;
        &amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/pre&gt; 
&lt;p&gt;我们再来看另一个bean，该bean的构造参数类型已知，匹配也没有问题(跟前面的例子一样)。但是当使用简单类型时，比如&lt;code&gt;&amp;lt;value&amp;gt;true&amp;lt;value&amp;gt;&lt;/code&gt;，Spring将无法知道该值的类型。不借助其他帮助，他将无法仅仅根据参数类型进行匹配，比如下面的这个例子：&lt;/p&gt; 
&lt;pre&gt;package examples;

public class ExampleBean {

    &lt;em&gt;// No. of years to the calculate the Ultimate Answer&lt;/em&gt;
    private int years;

    &lt;em&gt;// The Answer to Life, the Universe, and Everything&lt;/em&gt;
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}&lt;/pre&gt; 
&lt;span id="OSC_h6_5"&gt;&lt;/span&gt;
&lt;h6&gt;1.1.1.1. 构造器参数类型匹配&lt;/h6&gt; 
&lt;p&gt;针对上面的场景&lt;em&gt;可以&lt;/em&gt;通过使用&lt;code&gt;'type'&lt;/code&gt;属性来显式指定那些简单类型的构造参数的类型，比如：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="exampleBean" class="examples.ExampleBean"&amp;gt;
  &amp;lt;constructor-arg type="int" value="7500000"/&amp;gt;
  &amp;lt;constructor-arg type="java.lang.String" value="42"/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;span id="OSC_h6_6"&gt;&lt;/span&gt;
&lt;h6&gt;1.1.1.2. 构造参数索引&lt;/h6&gt; 
&lt;p&gt;我们还可以通过&lt;code&gt;index&lt;/code&gt;属性来显式指定构造参数的索引，比如下面的例子：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="exampleBean" class="examples.ExampleBean"&amp;gt;
  &amp;lt;constructor-arg index="0" value="7500000"/&amp;gt;
  &amp;lt;constructor-arg index="1" value="42"/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;p&gt;通过使用索引属性不但可以解决多个简单属性的混淆问题，还可以解决有可能有相同类型的2个构造参数的混淆问题了，注意&lt;em&gt;index是从0开始&lt;/em&gt;。&lt;/p&gt; 
&lt;span id="OSC_h4_7"&gt;&lt;/span&gt;
&lt;h4&gt;1.2. Setter注入&lt;/h4&gt; 
&lt;p&gt;通过调用无参构造器或无参&lt;code&gt;static&lt;/code&gt;工厂方法实例化bean之后，调用该bean的setter方法，即可实现&lt;em&gt;基于setter&lt;/em&gt;的DI。&lt;/p&gt; 
&lt;p&gt;下面的例子将展示只使用setter注入依赖。注意，这个类并没有什么&lt;em&gt;特别&lt;/em&gt;之处，它就是普通的Java类。&lt;/p&gt; 
&lt;pre&gt;public class SimpleMovieLister {

    &lt;em&gt;// the &lt;code&gt;SimpleMovieLister&lt;/code&gt; has a dependency on the &lt;code&gt;MovieFinder&lt;/code&gt;&lt;/em&gt;
    private MovieFinder movieFinder;

    &lt;em&gt;// a setter method so that the Spring container can 'inject' a &lt;code&gt;MovieFinder&lt;/code&gt;&lt;/em&gt;
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    &lt;em&gt;// business logic that actually 'uses' the injected &lt;code&gt;MovieFinder&lt;/code&gt; is omitted...&lt;/em&gt;
}&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;构造器注入还是Setter注入?&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;由于大量的构造器参数可能使程序变得笨拙，特别是当某些属性是可选的时候。因此通常情况下，Spring开发团队提倡使用setter注入。而且setter DI在以后的某个时候还可将实例重新配置（或重新注入）（&lt;a rel="nofollow"&gt;JMX MBean&lt;/a&gt;就是一个很好的例子）。&lt;/p&gt; 
&lt;p&gt;尽管如此，构造器注入还是得到很多纯化论者（也有很好的理由）的青睐。一次性将所有依赖注入的做法意味着，在未完全初始化的状态下，此对象不会返回给客户代码（或被调用），此外对象也不需要再次被重新配置（或重新注入）。&lt;/p&gt; 
&lt;p&gt;对于注入类型的选择并没硬性的规定。只要能适合你的应用，无论使用何种类型的DI都可以。对于那些没有源代码的第三方类，或者没有提供setter方法的遗留代码，我们则别无选择－－构造器注入将是你唯一的选择。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt;对于它所管理的bean提供两种注入依赖方式（实际上它也支持同时使用构造器注入和Setter方式注入依赖）。需要注入的依赖将保存在&lt;code&gt;BeanDefinition&lt;/code&gt;中，它能根据指定的&lt;code&gt;PropertyEditor&lt;/code&gt;实现将属性从一种格式转换成另外一种格式。然而，大部份的Spring用户并不需要直接以编程的方式处理这些类，而是采用XML的方式来进行定义，在内部这些定义将被转换成相应类的实例，并最终得到一个Spring IoC容器实例。&lt;/p&gt; 
&lt;p&gt;处理bean依赖关系通常按以下步骤进行：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;根据定义bean的配置（文件）创建并初始化&lt;code&gt;BeanFactory&lt;/code&gt;实例（大部份的Spring用户使用支持XML格式配置文件的&lt;code&gt;BeanFactory&lt;/code&gt;或&lt;code&gt;ApplicationContext&lt;/code&gt;实现）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;每个bean的依赖将以属性、构造器参数、或静态工厂方法参数的形式出现。&lt;em&gt;当这些bean被实际创建时&lt;/em&gt;，这些依赖也将会提供给该bean。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;每个属性或构造器参数既可以是一个实际的值，也可以是对该容器中另一个bean的引用。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;每个指定的属性或构造器参数值必须能够被转换成特定的格式或构造参数所需的类型。默认情况下，Spring会以String类型提供值转换成各种内置类型，比如&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;Spring会在容器被创建时验证容器中每个bean的配置，包括验证那些bean所引用的属性是否指向一个有效的bean（即被引用的bean也在容器中被定义）。然而，在bean&lt;em&gt;被实际创建&lt;/em&gt;之前，bean的属性并不会被设置。对于那些singleton类型和被设置为提前实例化的bean（比如&lt;code&gt;ApplicationContext&lt;/code&gt;中的singleton bean）而言，bean实例将与容器同时被创建。而另外一些bean则会在需要的时候被创建，伴随着bean被实际创建，作为该bean的依赖bean以及依赖bean的依赖bean（依此类推）也将被创建和分配。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;循环依赖&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在采用构造器注入的方式配置bean时，很有可能会产生循环依赖的情况。&lt;/p&gt; 
&lt;p&gt;比如说，一个类A，需要通过构造器注入类B，而类B又需要通过构造器注入类A。如果为类A和B配置的bean被互相注入的话，那么Spring IoC容器将检测出循环引用，并抛出 &lt;code&gt;BeanCurrentlyInCreationException&lt;/code&gt;异常。&lt;/p&gt; 
&lt;p&gt;对于此问题，一个可能的解决方法就是修改源代码，将某些构造器注入改为setter注入。另一个解决方法就是完全放弃构造器注入，只使用setter注入。换句话说，除了极少数例外，大部分的循环依赖都是可以避免的，不过采用setter注入产生循环依赖的可能性也是存在的。&lt;/p&gt; 
&lt;p&gt;与&lt;em&gt;通常&lt;/em&gt;我们见到的非循环依赖的情况有所不同，在两个bean之间的循环依赖将导致一个bean在被完全初始化的时候被注入到另一个bean中（如同我们常说的先有蛋还是先有鸡的情况）。&lt;/p&gt; 
&lt;p&gt;通常情况下，你可以信赖Spring，它会在容器加载时发现配置错误（比如对无效bean的引用以及循环依赖）。Spring会在bean创建时才去设置属性和依赖关系（只在需要时创建所依赖的其他对象）。这意味着即使Spring容器被正确加载，当获取一个bean实例时，如果在创建bean或者设置依赖时出现问题，仍然会抛出一个异常。因缺少或设置了一个无效属性而导致抛出一个异常的情况的确是存在的。因为一些配置问题而导致潜在的可见性被延迟，所以在默认情况下，&lt;code&gt;ApplicationContext&lt;/code&gt;实现中的bean采用提前实例化的singleton模式。在实际需要之前创建这些bean将带来时间与内存的开销。而这样做的好处就是&lt;code&gt;ApplicationContext&lt;/code&gt;被加载的时候可以尽早的发现一些配置的问题。不过用户也可以根据需要采用延迟实例化来替代默认的singleton模式。&lt;/p&gt; 
&lt;p&gt;如果撇开循环依赖不谈，当协作bean被注入到依赖bean时，协作bean必须在依赖bean之前&lt;em&gt;完全&lt;/em&gt;配置好。例如bean A对bean B存在依赖关系，那么Spring IoC容器在调用bean A的setter方法之前，bean B必须被完全配置，这里所谓&lt;em&gt;完全配置&lt;/em&gt;的意思就是bean将被实例化（如果不是采用提前实例化的singleton模式），相关的依赖也将被设置好，而且所有相关的lifecycle方法（如&lt;a rel="nofollow"&gt;IntializingBean&lt;/a&gt;的init方法以及callback方法）也将被调用。&lt;/p&gt; 
&lt;span id="OSC_h4_8"&gt;&lt;/span&gt;
&lt;h4&gt;1.3. 一些例子&lt;/h4&gt; 
&lt;p&gt;首先是一个用XML格式定义的Setter DI例子。相关的XML配置如下：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="exampleBean" class="examples.ExampleBean"&amp;gt;

  &lt;em&gt;&amp;lt;!-- setter injection using the nested &lt;code&gt;&amp;lt;ref/&amp;gt;&lt;/code&gt; element --&amp;gt;&lt;/em&gt;
  &amp;lt;property name="beanOne"&amp;gt;&amp;lt;ref bean="anotherExampleBean"/&amp;gt;&amp;lt;/property&amp;gt;

  &lt;em&gt;&amp;lt;!-- setter injection using the neater 'ref' attribute --&amp;gt;&lt;/em&gt;
  &amp;lt;property name="beanTwo" ref="yetAnotherBean"/&amp;gt;
  &amp;lt;property name="integerProperty" value="1"/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&amp;gt;
&amp;lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&amp;gt;&lt;/pre&gt; 
&lt;pre&gt;public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }    
}&lt;/pre&gt; 
&lt;p&gt;正如你所看到的，bean类中的setter方法与xml文件中配置的属性是一一对应的。接着是构造器注入的例子：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="exampleBean" class="examples.ExampleBean"&amp;gt;

  &lt;em&gt;&amp;lt;!-- constructor injection using the nested &lt;code&gt;&amp;lt;ref/&amp;gt;&lt;/code&gt; element --&amp;gt;&lt;/em&gt;
  &amp;lt;constructor-arg&amp;gt;
    &amp;lt;ref bean="anotherExampleBean"/&amp;gt;
  &amp;lt;/constructor-arg&amp;gt;
  
  &lt;em&gt;&amp;lt;!-- constructor injection using the neater 'ref' attribute --&amp;gt;&lt;/em&gt;
  &amp;lt;constructor-arg ref="yetAnotherBean"/&amp;gt;
  
  &amp;lt;constructor-arg type="int" value="1"/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&amp;gt;
&amp;lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&amp;gt;&lt;/pre&gt; 
&lt;pre&gt;public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}&lt;/pre&gt; 
&lt;p&gt;如你所见，在xml bean定义中指定的构造器参数将被用来作为传递给类&lt;code&gt;ExampleBean&lt;/code&gt;构造器的参数。&lt;/p&gt; 
&lt;p&gt;现在来研究一个替代构造器的方法，采用&lt;code&gt;static&lt;/code&gt;工厂方法返回对象实例：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="exampleBean" class="examples.ExampleBean"
      factory-method="createInstance"&amp;gt;
  &amp;lt;constructor-arg ref="anotherExampleBean"/&amp;gt;
  &amp;lt;constructor-arg ref="yetAnotherBean"/&amp;gt;
  &amp;lt;constructor-arg value="1"/&amp;gt; 
&amp;lt;/bean&amp;gt;

&amp;lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&amp;gt;
&amp;lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&amp;gt;&lt;/pre&gt; 
&lt;pre&gt;public class ExampleBean {

    &lt;em&gt;// a private constructor&lt;/em&gt;
    private ExampleBean(...) {
      ...
    }
    &lt;em&gt;
    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.&lt;/em&gt;
    public static ExampleBean createInstance (
            AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        &lt;em&gt;// some other operations...&lt;/em&gt;
        return eb;
    }
}&lt;/pre&gt; 
&lt;p&gt;请注意，传给&lt;code&gt;static&lt;/code&gt;工厂方法的参数由&lt;code&gt;constructor-arg&lt;/code&gt;元素提供，这与使用构造器注入时完全一样。而且，重要的是，工厂方法所返回的实例的类型并不一定要与包含&lt;code&gt;static&lt;/code&gt;工厂方法的类类型一致。尽管在此例子中它的确是这样。非静态的实例工厂方法与此相同（除了使用&lt;code&gt;factory-bean&lt;/code&gt;属性替代&lt;code&gt;class&lt;/code&gt;属性外），因而不在此细述。&lt;/p&gt; 
&lt;span id="OSC_h3_9"&gt;&lt;/span&gt;
&lt;h3&gt;2. 依赖配置详解&lt;/h3&gt; 
&lt;p&gt;正如前面章节所提到的，bean的属性及构造器参数既可以引用容器中的其他bean，也可以是内联（inline）bean。在spring的XML配置中使用&lt;code&gt;&amp;lt;property/&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;constructor-arg/&amp;gt;&lt;/code&gt;元素定义。&lt;/p&gt; 
&lt;span id="OSC_h4_10"&gt;&lt;/span&gt;
&lt;h4&gt;2.1. 直接变量(基本类型、&lt;code&gt;Strings&lt;/code&gt;类型等。)&lt;/h4&gt; 
&lt;p&gt;&lt;code&gt;&amp;lt;value/&amp;gt;&lt;/code&gt;元素通过人可以理解的字符串来指定属性或构造器参数的值。正如&lt;a rel="nofollow"&gt;前面&lt;/a&gt;所提到的，JavaBean &lt;code&gt;PropertyEditor&lt;/code&gt;将用于把字符串从&lt;code&gt;java.lang.String&lt;/code&gt;类型转化为实际的属性或参数类型。&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&amp;gt;
  
  &lt;em&gt;&amp;lt;!-- results in a &lt;code&gt;setDriverClassName(String)&lt;/code&gt; call --&amp;gt;&lt;/em&gt;
  &amp;lt;property name="driverClassName"&amp;gt;
    &amp;lt;value&amp;gt;com.mysql.jdbc.Driver&amp;lt;/value&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property name="url"&amp;gt;
    &amp;lt;value&amp;gt;jdbc:mysql://localhost:3306/mydb&amp;lt;/value&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property name="username"&amp;gt;
    &amp;lt;value&amp;gt;root&amp;lt;/value&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property name="password"&amp;gt;
    &amp;lt;value&amp;gt;masterkaoli&amp;lt;/value&amp;gt;
  &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;&amp;lt;property/&amp;gt;&lt;/code&gt; 和&lt;code&gt;&amp;lt;constructor-arg/&amp;gt;&lt;/code&gt; 元素中也可以使用&lt;code&gt;'value'&lt;/code&gt; 属性，这样会使我们的配置更简洁，比如下面的配置：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&amp;gt;
  
  &lt;em&gt;&amp;lt;!-- results in a &lt;code&gt;setDriverClassName(String)&lt;/code&gt; call --&amp;gt;&lt;/em&gt;
  &amp;lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&amp;gt;
  &amp;lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/&amp;gt;
  &amp;lt;property name="username" value="root"/&amp;gt;
  &amp;lt;property name="password" value="masterkaoli"/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;p&gt;Spring团队更倾向采用属性方式（使用&lt;code&gt;&amp;lt;value/&amp;gt;&lt;/code&gt;元素）来定义value值。当然我们也可以按照下面这种方式配置一个&lt;code&gt;java.util.Properties&lt;/code&gt;实例：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="mappings" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&amp;gt;
            
   &lt;em&gt;&amp;lt;!-- typed as a &lt;code&gt;java.util.Properties&lt;/code&gt; --&amp;gt;&lt;/em&gt;
   &amp;lt;property name="properties"&amp;gt;
      &amp;lt;value&amp;gt;
         jdbc.driver.className=com.mysql.jdbc.Driver
         jdbc.url=jdbc:mysql://localhost:3306/mydb
      &amp;lt;/value&amp;gt;
   &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;p&gt;看到什么了吗？如果采用上面的配置，Spring容器将使用JavaBean &lt;code&gt;PropertyEditor&lt;/code&gt;把&lt;code&gt;&amp;lt;value/&amp;gt;&lt;/code&gt;元素中的文本转换为一个&lt;code&gt;java.util.Properties&lt;/code&gt;实例。由于这种做法的简单，因此Spring团队在很多地方也会采用内嵌的&lt;code&gt;&amp;lt;value/&amp;gt;&lt;/code&gt;元素来代替&lt;code&gt;value&lt;/code&gt;属性。&lt;/p&gt; 
&lt;span id="OSC_h5_11"&gt;&lt;/span&gt;
&lt;h5&gt;2.1.1. &lt;code&gt;idref&lt;/code&gt;元素&lt;/h5&gt; 
&lt;p&gt;&lt;code&gt;idref&lt;/code&gt;元素用来将容器内其它bean的&lt;em&gt;id&lt;/em&gt;传给&lt;code&gt;&amp;lt;constructor-arg/&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;property/&amp;gt;&lt;/code&gt;元素，同时提供错误验证功能。&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="theTargetBean" class="..."/&amp;gt;

&amp;lt;bean id="theClientBean" class="..."&amp;gt;
    &amp;lt;property name="targetName"&amp;gt;
        &amp;lt;idref bean="theTargetBean" /&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;p&gt;上述bean定义片段&lt;em&gt;完全地&lt;/em&gt;等同于（在运行时）以下的片段：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="theTargetBean" class="..." /&amp;gt;

&amp;lt;bean id="client" class="..."&amp;gt;
    &amp;lt;property name="targetName" value="theTargetBean" /&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;p&gt;第一种形式比第二种更可取的主要原因是，使用&lt;code&gt;idref&lt;/code&gt;标记允许容器&lt;em&gt;在部署时&lt;/em&gt; 验证所被引用的bean是否存在。而第二种方式中，传给&lt;code&gt;client&lt;/code&gt; bean的&lt;code&gt;targetName&lt;/code&gt;属性值并没有被验证。任何的输入错误仅在&lt;code&gt;client&lt;/code&gt; bean实际实例化时才会被发现（可能伴随着致命的错误）。如果&lt;code&gt;client&lt;/code&gt; bean 是&lt;a rel="nofollow"&gt;prototype&lt;/a&gt;类型的bean，则此输入错误（及由此导致的异常）可能在容器部署很久以后才会被发现。&lt;/p&gt; 
&lt;p&gt;此外，如果被引用的bean在同一XML文件内，且bean名字就是bean &lt;em&gt;id&lt;/em&gt;，那么可以使用&lt;code&gt;local&lt;/code&gt;属性，此属性允许XML解析器在解析XML文件时对引用的bean进行验证。&lt;/p&gt; 
&lt;pre&gt;&amp;lt;property name="targetName"&amp;gt;
   &lt;em&gt;&amp;lt;!-- a bean with an id of '&lt;code&gt;theTargetBean&lt;/code&gt;' must exist; otherwise an XML exception will be thrown --&amp;gt;&lt;/em&gt;
   &amp;lt;idref local="theTargetBean"/&amp;gt;
&amp;lt;/property&amp;gt;&lt;/pre&gt; 
&lt;p&gt;上面的例子中，与在&lt;code&gt;ProxyFactoryBean&lt;/code&gt; bean定义中使用&amp;lt;idref/&amp;gt;元素指定&lt;a rel="nofollow"&gt;AOP interceptor&lt;/a&gt;的相同之处在于：如果使用&amp;lt;idref/&amp;gt;元素指定拦截器名字，可以避免因一时疏忽导致的拦截器ID拼写错误。&lt;/p&gt; 
&lt;span id="OSC_h4_12"&gt;&lt;/span&gt;
&lt;h4&gt;2.2. 引用其它的bean（协作者）&lt;/h4&gt; 
&lt;p&gt;在&lt;code&gt;&amp;lt;constructor-arg/&amp;gt;&lt;/code&gt;或&lt;code&gt;&amp;lt;property/&amp;gt;&lt;/code&gt;元素内部还可以使用&lt;code&gt;ref&lt;/code&gt;元素。该元素用来将bean中指定属性的值设置为对容器中的另外一个bean的引用。如前所述，该引用bean将被作为依赖注入，而且在注入之前会被初始化（如果是singleton bean则已被容器初始化）。尽管都是对另外一个对象的引用，但是通过id/name指向另外一个对象却有三种不同的形式，不同的形式将决定如何处理作用域及验证。&lt;/p&gt; 
&lt;p&gt;第一种形式也是最常见的形式是通过使用&lt;code&gt;&amp;lt;ref/&amp;gt;&lt;/code&gt;标记指定&lt;code&gt;bean&lt;/code&gt;属性的目标bean，通过该标签可以引用同一容器或父容器内的任何bean（无论是否在同一XML文件中）。XML '&lt;code&gt;bean&lt;/code&gt;'元素的值既可以是指定bean的&lt;code&gt;id&lt;/code&gt;值也可以是其&lt;code&gt;name&lt;/code&gt;值。&lt;/p&gt; 
&lt;pre&gt;&amp;lt;ref bean="someBean"/&amp;gt;&lt;/pre&gt; 
&lt;p&gt;第二种形式是使用ref的&lt;code&gt;local&lt;/code&gt;属性指定目标bean，它可以利用XML解析器来验证所引用的bean是否存在同一文件中。&lt;code&gt;local&lt;/code&gt;属性值必须是目标bean的id属性值。如果在同一配置文件中没有找到引用的bean，XML解析器将抛出一个例外。如果目标bean是在同一文件内，使用local方式就是最好的选择（为了尽早地发现错误）。&lt;/p&gt; 
&lt;pre&gt;&amp;lt;ref local="someBean"/&amp;gt;&lt;/pre&gt; 
&lt;p&gt;第三种方式是通过使用ref的&lt;code&gt;parent&lt;/code&gt;属性来引用当前容器的父容器中的bean。&lt;code&gt;parent&lt;/code&gt;属性值既可以是目标bean的&lt;code&gt;id&lt;/code&gt;值，也可以是&lt;code&gt;name&lt;/code&gt;属性值。而且目标bean必须在当前容器的父容器中。使用parent属性的主要用途是为了用某个与父容器中的bean同名的代理来包装父容器中的一个bean(例如，子上下文中的一个bean定义覆盖了他的父bean)。&lt;/p&gt; 
&lt;pre&gt;&lt;em&gt;&amp;lt;!-- in the parent context --&amp;gt;&lt;/em&gt;
&amp;lt;bean id="accountService" class="com.foo.SimpleAccountService"&amp;gt;
    &lt;em&gt;&amp;lt;!-- insert dependencies as required as here --&amp;gt;&lt;/em&gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;em&gt;&amp;lt;!-- in the child (descendant) context --&amp;gt;&lt;/em&gt;
&amp;lt;bean id="accountService"  &lt;em&gt;&amp;lt;-- notice that the name of this bean is the &lt;strong&gt;same&lt;/strong&gt; as the name of the &lt;code&gt;'parent'&lt;/code&gt; bean&lt;/em&gt;
      class="org.springframework.aop.framework.ProxyFactoryBean"&amp;gt;
      &amp;lt;property name="target"&amp;gt;
          &amp;lt;ref parent="accountService"/&amp;gt;  &lt;em&gt;&amp;lt;-- notice how we refer to the &lt;strong&gt;parent&lt;/strong&gt; bean&lt;/em&gt;
      &amp;lt;/property&amp;gt;
    &lt;em&gt;&amp;lt;!-- insert other configuration and dependencies as required as here --&amp;gt;&lt;/em&gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;span id="OSC_h4_13"&gt;&lt;/span&gt;
&lt;h4&gt;2.3. 内部bean&lt;/h4&gt; 
&lt;p&gt;所谓的内部bean（inner bean）是指在一个bean的&lt;code&gt;&amp;lt;property/&amp;gt;&lt;/code&gt;或 &lt;code&gt;&amp;lt;constructor-arg/&amp;gt;&lt;/code&gt;元素中使用&lt;code&gt;&amp;lt;bean/&amp;gt;&lt;/code&gt;元素定义的bean。内部bean定义不需要有id或name属性，即使指定id 或 name属性值也将会被容器忽略。&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="outer" class="..."&amp;gt;
  &lt;em&gt;&amp;lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&amp;gt;&lt;/em&gt;
  &amp;lt;property name="target"&amp;gt;
    &amp;lt;bean class="com.example.Person"&amp;gt; &lt;em&gt;&amp;lt;!-- this is the inner bean --&amp;gt;&lt;/em&gt;
      &amp;lt;property name="name" value="Fiona Apple"/&amp;gt;
      &amp;lt;property name="age" value="25"/&amp;gt;
    &amp;lt;/bean&amp;gt;
  &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;p&gt;注意：内部bean中的&lt;code&gt;scope&lt;/code&gt;标记及&lt;code&gt;id&lt;/code&gt;或&lt;code&gt;name&lt;/code&gt;属性将被忽略。内部bean&lt;em&gt;总是&lt;/em&gt;匿名的且它们&lt;em&gt;总是&lt;/em&gt;&lt;a rel="nofollow"&gt;prototype&lt;/a&gt;模式的。同时将内部bean注入到包含该内部bean之外的bean是&lt;em&gt;不&lt;/em&gt;可能的。&lt;/p&gt; 
&lt;span id="OSC_h4_14"&gt;&lt;/span&gt;
&lt;h4&gt;2.4. 集合&lt;/h4&gt; 
&lt;p&gt;通过&lt;code&gt;&amp;lt;list/&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;set/&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;map/&amp;gt;&lt;/code&gt;及&lt;code&gt;&amp;lt;props/&amp;gt;&lt;/code&gt;元素可以定义和设置与Java &lt;code&gt;Collection&lt;/code&gt;类型对应&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;Map&lt;/code&gt;及&lt;code&gt;Properties&lt;/code&gt;的值。&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="moreComplexObject" class="example.ComplexObject"&amp;gt;
  &lt;em&gt;&amp;lt;!-- results in a setAdminEmails(&lt;code&gt;java.util.Properties&lt;/code&gt;) call --&amp;gt;&lt;/em&gt;
  &amp;lt;property name="adminEmails"&amp;gt;
    &amp;lt;props&amp;gt;
        &amp;lt;prop key="administrator"&amp;gt;administrator@example.org&amp;lt;/prop&amp;gt;
        &amp;lt;prop key="support"&amp;gt;support@example.org&amp;lt;/prop&amp;gt;
        &amp;lt;prop key="development"&amp;gt;development@example.org&amp;lt;/prop&amp;gt;
    &amp;lt;/props&amp;gt;
  &amp;lt;/property&amp;gt;
  &lt;em&gt;&amp;lt;!-- results in a setSomeList(&lt;code&gt;java.util.List&lt;/code&gt;) call --&amp;gt;&lt;/em&gt;
  &amp;lt;property name="someList"&amp;gt;
    &amp;lt;list&amp;gt;
        &amp;lt;value&amp;gt;a list element followed by a reference&amp;lt;/value&amp;gt;
        &amp;lt;ref bean="myDataSource" /&amp;gt;
    &amp;lt;/list&amp;gt;
  &amp;lt;/property&amp;gt;
  &lt;em&gt;&amp;lt;!-- results in a setSomeMap(&lt;code&gt;java.util.Map&lt;/code&gt;) call --&amp;gt;&lt;/em&gt;
  &amp;lt;property name="someMap"&amp;gt;
    &amp;lt;map&amp;gt;
        &amp;lt;entry&amp;gt;
            &amp;lt;key&amp;gt;
                &amp;lt;value&amp;gt;an entry&amp;lt;/value&amp;gt;
            &amp;lt;/key&amp;gt;
            &amp;lt;value&amp;gt;just some string&amp;lt;/value&amp;gt;
        &amp;lt;/entry&amp;gt;
        &amp;lt;entry&amp;gt;
            &amp;lt;key&amp;gt;
                &amp;lt;value&amp;gt;a ref&amp;lt;/value&amp;gt;
            &amp;lt;/key&amp;gt;
            &amp;lt;ref bean="myDataSource" /&amp;gt;
        &amp;lt;/entry&amp;gt;
    &amp;lt;/map&amp;gt;
  &amp;lt;/property&amp;gt;
  &lt;em&gt;&amp;lt;!-- results in a setSomeSet(java.util.Set) call --&amp;gt;&lt;/em&gt;
  &amp;lt;property name="someSet"&amp;gt;
    &amp;lt;set&amp;gt;
        &amp;lt;value&amp;gt;just some string&amp;lt;/value&amp;gt;
        &amp;lt;ref bean="myDataSource" /&amp;gt;
    &amp;lt;/set&amp;gt;
  &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;p&gt;&lt;em&gt;注意：map的key或value值，或set的value值还可以是以下元素：&lt;/em&gt;&lt;/p&gt; 
&lt;pre&gt;bean | ref | idref | list | set | map | props | value | null&lt;/pre&gt; 
&lt;span id="OSC_h5_15"&gt;&lt;/span&gt;
&lt;h5&gt;2.4.1. 集合的合并&lt;/h5&gt; 
&lt;p&gt;从2.0开始，Spring IoC容器将支持集合的&lt;em&gt;合并&lt;/em&gt;。这样我们可以定义parent-style和child-style的&lt;code&gt;&amp;lt;list/&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;map/&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;set/&amp;gt;&lt;/code&gt;或&lt;code&gt;&amp;lt;props/&amp;gt;&lt;/code&gt;元素，子集合的值从其父集合继承和覆盖而来；也就是说，父子集合元素合并后的值就是子集合中的最终结果，而且子集合中的元素值将覆盖父集全中对应的值。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;请注意，关于合并的这部分利用了parent-child bean机制。此内容将在后面介绍，不熟悉父子bean的读者可参见&lt;a rel="nofollow"&gt;第 3.6 节 “bean定义的继承”&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;Find below an example of the collection merging feature:&lt;/p&gt; 
&lt;p&gt;下面的例子展示了集合合并特性：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;beans&amp;gt;
&amp;lt;bean id="parent" abstract="true" class="example.ComplexObject"&amp;gt;
    &amp;lt;property name="adminEmails"&amp;gt;
        &amp;lt;props&amp;gt;
            &amp;lt;prop key="administrator"&amp;gt;administrator@example.com&amp;lt;/prop&amp;gt;
            &amp;lt;prop key="support"&amp;gt;support@example.com&amp;lt;/prop&amp;gt;
        &amp;lt;/props&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id="child" parent="parent"&amp;gt;
    &amp;lt;property name="adminEmails"&amp;gt;
        &lt;em&gt;&amp;lt;!-- the merge is specified on the *child* collection definition --&amp;gt;&lt;/em&gt;
        &amp;lt;props merge="true"&amp;gt;
            &amp;lt;prop key="sales"&amp;gt;sales@example.com&amp;lt;/prop&amp;gt;
            &amp;lt;prop key="support"&amp;gt;support@example.co.uk&amp;lt;/prop&amp;gt;
        &amp;lt;/props&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;beans&amp;gt;&lt;/pre&gt; 
&lt;p&gt;在上面的例子中，&lt;code&gt;child&lt;/code&gt;bean的&lt;code&gt;adminEmails&lt;/code&gt;属性的&lt;code&gt;&amp;lt;props/&amp;gt;&lt;/code&gt;元素上使用了&lt;code&gt;merge=true&lt;/code&gt;属性。当&lt;code&gt;child &lt;/code&gt;bean被容器实际解析及实例化时，其 &lt;code&gt;adminEmails&lt;/code&gt;将与父集合的&lt;code&gt;adminEmails&lt;/code&gt;属性进行合并。&lt;/p&gt; 
&lt;pre&gt;administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk&lt;/pre&gt; 
&lt;p&gt;注意到这里子bean的&lt;code&gt;Properties&lt;/code&gt;集合将从父&lt;code&gt;&amp;lt;props/&amp;gt;&lt;/code&gt;继承所有属性元素。同时子bean的&lt;code&gt;support&lt;/code&gt;值将覆盖父集合的相应值。&lt;/p&gt; 
&lt;p&gt;对于&lt;code&gt;&amp;lt;list/&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;map/&amp;gt;&lt;/code&gt;及&lt;code&gt;&amp;lt;set/&amp;gt;&lt;/code&gt;集合类型的合并处理都基本类似，在某个方面&lt;code&gt;&amp;lt;list/&amp;gt;&lt;/code&gt;元素比较特殊，这涉及到&lt;code&gt;List&lt;/code&gt;集合本身的语义学，就拿维护一个&lt;code&gt;有序&lt;/code&gt;集合中的值来说，父bean的列表内容将排在子bean列表内容的前面。对于&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;及&lt;code&gt;Properties&lt;/code&gt;集合类型没有顺序的概念，因此作为相关的&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;及&lt;code&gt;Properties&lt;/code&gt;实现基础的集合类型在容器内部没有排序的语义。&lt;/p&gt; 
&lt;p&gt;最后需要指出的一点就是，合并功能仅在Spring 2.0（及随后的版本中）可用。不同的集合类型是不能合并（如&lt;code&gt;map&lt;/code&gt;和 &lt;code&gt;list&lt;/code&gt;是不能合并的），否则将会抛出相应的&lt;code&gt;Exception&lt;/code&gt;。&lt;code&gt;merge&lt;/code&gt;属性必须在继承的子bean中定义，而在父bean的集合属性上指定的&lt;code&gt;merge&lt;/code&gt;属性将被忽略。&lt;/p&gt; 
&lt;span id="OSC_h5_16"&gt;&lt;/span&gt;
&lt;h5&gt;2.4.2. 强类型集合(仅适用于Java5+)&lt;/h5&gt; 
&lt;p&gt;你若有幸在使用Java5 或Java 6，那么你可以使用强类型集合(支持泛型)。比如，声明一个只能包含&lt;code&gt;String&lt;/code&gt;类型元素的&lt;code&gt;Collection&lt;/code&gt;。假若使用Spring来给bean注入强类型的&lt;code&gt;Collection&lt;/code&gt;，那就可以利用Spring的类型转换能，当向强类型&lt;code&gt;Collection&lt;/code&gt;中添加元素前，这些元素将被转换。&lt;/p&gt; 
&lt;pre&gt;public class Foo {
                
    private Map&amp;lt;String, Float&amp;gt; accounts;
    
    public void setAccounts(Map&amp;lt;String, Float&amp;gt; accounts) {
        this.accounts = accounts;
    }
}&lt;/pre&gt; 
&lt;pre&gt;&amp;lt;beans&amp;gt;
    &amp;lt;bean id="foo" class="x.y.Foo"&amp;gt;
        &amp;lt;property name="accounts"&amp;gt;
            &amp;lt;map&amp;gt;
                &amp;lt;entry key="one" value="9.99"/&amp;gt;
                &amp;lt;entry key="two" value="2.75"/&amp;gt;
                &amp;lt;entry key="six" value="3.99"/&amp;gt;
            &amp;lt;/map&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/pre&gt; 
&lt;p&gt;在&lt;code&gt;foo&lt;/code&gt;bean的&lt;code&gt;accounts&lt;/code&gt;属性被注入之前，通过反射，利用强类型&lt;code&gt;Map&amp;lt;String, Float&amp;gt;&lt;/code&gt;的泛型信息，Spring的底层类型转换机制将会把各种value元素值转换为&lt;code&gt;Float&lt;/code&gt;类型，因此字符串&lt;code&gt;9.99、2.75&lt;/code&gt;及&lt;code&gt;3.99&lt;/code&gt;就会被转换为实际的&lt;code&gt;Float&lt;/code&gt;类型。&lt;/p&gt; 
&lt;span id="OSC_h4_17"&gt;&lt;/span&gt;
&lt;h4&gt;2.5. &lt;code&gt;Nulls&lt;/code&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;code&gt;&amp;lt;null/&amp;gt;&lt;/code&gt;用于处理&lt;code&gt;null&lt;/code&gt;值。Spring会把属性的空参数当作空&lt;code&gt;字符串&lt;/code&gt;处理。以下的xml片断将email属性设为空&lt;code&gt;字符串&lt;/code&gt;。&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean class="ExampleBean"&amp;gt;
  &amp;lt;property name="email"&amp;gt;&amp;lt;value/&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;p&gt;这等同于Java代码： &lt;code&gt;exampleBean.setEmail("")&lt;/code&gt;。而&lt;code&gt;null&lt;/code&gt;值则可以使用&lt;code&gt;&amp;lt;null&amp;gt;&lt;/code&gt;元素可用来表示。例如：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean class="ExampleBean"&amp;gt;
  &amp;lt;property name="email"&amp;gt;&amp;lt;null/&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;p&gt;上述的配置等同于Java代码：&lt;code&gt;exampleBean.setEmail(null)&lt;/code&gt;。&lt;/p&gt; 
&lt;span id="OSC_h4_18"&gt;&lt;/span&gt;
&lt;h4&gt;2.6. XML配置文件的简写及其他&lt;/h4&gt; 
&lt;p&gt;配置元数据冗长不是什么好事情，因此我们将通过下面的方式来对配置进行“减肥”，第一种做法就是通过使用&lt;code&gt;&amp;lt;property/&amp;gt;&lt;/code&gt;来定义值和对其他bean的引用，另一个做法就是采用不同的属性定义格式。&lt;/p&gt; 
&lt;span id="OSC_h5_19"&gt;&lt;/span&gt;
&lt;h5&gt;2.6.1. XML-based configuration metadata shortcuts&lt;/h5&gt; 
&lt;p&gt;&lt;code&gt;&amp;lt;property/&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;constructor-arg/&amp;gt;&lt;/code&gt;及&lt;code&gt;&amp;lt;entry/&amp;gt;&lt;/code&gt;元素都支持&lt;code&gt;value&lt;/code&gt;属性（attribute），它可以用来替代内嵌的&lt;code&gt;&amp;lt;value/&amp;gt;&lt;/code&gt;元素。因而，以下的代码：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;property name="myProperty"&amp;gt;
  &amp;lt;value&amp;gt;hello&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/pre&gt; 
&lt;pre&gt;&amp;lt;constructor-arg&amp;gt;
  &amp;lt;value&amp;gt;hello&amp;lt;/value&amp;gt;
&amp;lt;/constructor-arg&amp;gt;&lt;/pre&gt; 
&lt;pre&gt;&amp;lt;entry key="myKey"&amp;gt;
  &amp;lt;value&amp;gt;hello&amp;lt;/value&amp;gt;
&amp;lt;/entry&amp;gt;&lt;/pre&gt; 
&lt;p&gt;等同于：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;property name="myProperty" value="hello"/&amp;gt;&lt;/pre&gt; 
&lt;pre&gt;&amp;lt;constructor-arg value="hello"/&amp;gt;&lt;/pre&gt; 
&lt;pre&gt;&amp;lt;entry key="myKey" value="hello"/&amp;gt;&lt;/pre&gt; 
&lt;p&gt;The &lt;code&gt;&amp;lt;property/&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;constructor-arg/&amp;gt;&lt;/code&gt; elements support a similar shortcut &lt;code&gt;'ref'&lt;/code&gt; attribute which may be used instead of a full nested &lt;code&gt;&amp;lt;ref/&amp;gt;&lt;/code&gt; element. Therefore, the following:&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;&amp;lt;property/&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;constructor-arg/&amp;gt;&lt;/code&gt;支持类似&lt;code&gt;ref&lt;/code&gt;的简写属性，它可用来替代整个内嵌的&lt;code&gt;&amp;lt;ref/&amp;gt;&lt;/code&gt;元素。因而，以下的代码：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;property name="myProperty"&amp;gt;
  &amp;lt;ref bean="myBean"&amp;gt;
&amp;lt;/property&amp;gt;&lt;/pre&gt; 
&lt;pre&gt;&amp;lt;constructor-arg&amp;gt;
  &amp;lt;ref bean="myBean"&amp;gt;
&amp;lt;/constructor-arg&amp;gt;&lt;/pre&gt; 
&lt;p&gt;等同于：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;property name="myProperty" ref="myBean"/&amp;gt;&lt;/pre&gt; 
&lt;pre&gt;&amp;lt;constructor-arg ref="myBean"/&amp;gt;&lt;/pre&gt; 
&lt;p&gt;注意，尽管存在等同于&lt;code&gt;&amp;lt;ref bean="xxx"&amp;gt;&lt;/code&gt; 元素的简写形式，但并没有&lt;code&gt;&amp;lt;ref local="xxx"&lt;/code&gt;&amp;gt;的简写形式，为了对当前xml中bean的引用，你只能使用完整的形式。&lt;/p&gt; 
&lt;p&gt;最后，map中entry元素的简写形式为&lt;code&gt;key&lt;/code&gt;/&lt;code&gt;key-ref&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; /&lt;code&gt;value-ref&lt;/code&gt;属性，因而，以下的代码：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;entry&amp;gt;
  &amp;lt;key&amp;gt;
    &amp;lt;ref bean="myKeyBean" /&amp;gt;
  &amp;lt;/key&amp;gt;
  &amp;lt;ref bean="myValueBean" /&amp;gt;
&amp;lt;/entry&amp;gt;&lt;/pre&gt; 
&lt;p&gt;等同于：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;entry key-ref="myKeyBean" value-ref="myValueBean"/&amp;gt;&lt;/pre&gt; 
&lt;p&gt;再次强调，只有&lt;code&gt;&amp;lt;ref bean="xxx"&amp;gt;&lt;/code&gt;元素的简写形式，没有&lt;code&gt;&amp;lt;ref local="xxx"&lt;/code&gt;&amp;gt;的简写形式。&lt;/p&gt; 
&lt;span id="OSC_h5_20"&gt;&lt;/span&gt;
&lt;h5&gt;2.6.2. 使用p名称空间配置属性&lt;/h5&gt; 
&lt;p&gt;给XML配置文件"减肥"的另一个选择就是使用p名称空间，从 2.0开始，Spring支持使用&lt;a rel="nofollow"&gt;名称空间&lt;/a&gt;的可扩展配置格式。这些名称空间都是基于一种XML Schema定义。事实上，我们所看到的所有&lt;code&gt;bean&lt;/code&gt;的配置格式都是基于一个 XML Schema文档。&lt;/p&gt; 
&lt;p&gt;特定的名称空间并不需要定义在一个XSD文件中，它只在Spring内核中存在。我们所说的p名称空间就是这样，它不需要一个schema定义，与我们前面采用&lt;code&gt;&amp;lt;property/&amp;gt;&lt;/code&gt;元素定义bean的属性不同的是，当我们采用了p名称空间，我们就可以在&lt;code&gt;bean&lt;/code&gt;元素中使用属性（attribute）来描述bean的property值。&lt;/p&gt; 
&lt;p&gt;下面的两段XML配置文件中都是用来定义同一个bean：一个采用的是标准的XML格式，一个是采用p名称空间。&lt;/p&gt; 
&lt;pre&gt;&amp;lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&amp;gt;
    
    &amp;lt;bean name="classic" class="com.example.ExampleBean"&amp;gt;
        &amp;lt;property name="email" value="foo@bar.com/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;bean name="p-namespace" class="com.example.ExampleBean"
          p:email="foo@bar.com"/&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/pre&gt; 
&lt;p&gt;从上面的bean定义中，我们采用p名称空间的方式包含了一个叫email的属性，而Spring会知道我们的bean包含了一个属性（property）定义。我们前面说了，p名称空间是不需要schema定义的，因此属性（attribute）的名字就是你bean的property的名字。&lt;/p&gt; 
&lt;p&gt;This next example includes two more bean definitions that both have a reference to another bean:&lt;/p&gt; 
&lt;p&gt;下面的例子包含了两个bean定义，它们都引用了另一个bean&lt;/p&gt; 
&lt;pre&gt;&amp;lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&amp;gt;
    
    &amp;lt;bean name="john-classic" class="com.example.Person"&amp;gt;
        &amp;lt;property name="name" value="John Doe"/&amp;gt;
        &amp;lt;property name="spouse" ref="jane"/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean name="john-modern" 
        class="com.example.Person"
        p:name="John Doe"
        p:spouse-ref="jane"/&amp;gt;

    &amp;lt;bean name="jane" class="com.example.Person"&amp;gt;
        &amp;lt;property name="name" value="Jane Doe"/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/pre&gt; 
&lt;p&gt;As you can see, this example doesn't only include a property value using the p-namespace, but also uses a special format to declare property references. Whereas the first bean definition uses &lt;code&gt;&amp;lt;property name="spouse" ref="jane"/&amp;gt;&lt;/code&gt; to create a reference from bean &lt;code&gt;john&lt;/code&gt; to bean &lt;code&gt;jane&lt;/code&gt;, the second bean definition uses &lt;code&gt;p:spouse-ref="jane"&lt;/code&gt; as an attribute to do the exact same thing. In this case '&lt;code&gt;spouse&lt;/code&gt;' is the property name whereas the '&lt;code&gt;-ref&lt;/code&gt;' part indicates that this is not a straight value but rather a reference to another bean.&lt;/p&gt; 
&lt;p&gt;上面的例子不仅使用p名称空间包含了一个属性（property）值，而且使用了一个特殊的格式声明了一个属性引用。在第一个bean定义中使用了&lt;code&gt;&amp;lt;property name="spouse" ref="jane"/&amp;gt;&lt;/code&gt;来建立bean&lt;code&gt;john&lt;/code&gt;到bean&lt;code&gt;jane&lt;/code&gt;的引用，而第二个bean定义则采用&lt;code&gt;p:spouse-ref="jane"&lt;/code&gt;属性（attribute）的方式达到了同样的目的。在这个例子中，"&lt;code&gt;spouse&lt;/code&gt;"是属性（property）名，而"&lt;code&gt;-ref&lt;/code&gt;“则用来说明该属性不是一个具体的值而是对另外一个bean的引用。&lt;/p&gt; 
&lt;span id="OSC_h3_21"&gt;&lt;/span&gt;
&lt;h3&gt;注意&lt;/h3&gt; 
&lt;p&gt;需要注意的是，p名称空间没有标准的XML格式定义灵活，比如说，bean的属性名是以&lt;code&gt;Ref&lt;/code&gt;结尾的，那么采用p名称空间定义就会导致冲突，而采用标准的XML格式定义则不会出现这种问题。这里我们提醒大家在项目中还是仔细权衡来决定到底采用那种方式，同时也可以在团队成员都理解不同的定义方式的基础上，在项目中根据需要同时选择三种定义方式。&lt;/p&gt; 
&lt;span id="OSC_h4_22"&gt;&lt;/span&gt;
&lt;h4&gt;2.7. 组合属性名称&lt;/h4&gt; 
&lt;p&gt;当设置bean的组合属性时，除了最后一个属性外，只要其他属性值不为&lt;code&gt;null&lt;/code&gt;，组合或嵌套属性名是完全合法的。例如，下面bean的定义：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="foo" class="foo.Bar"&amp;gt;
  &amp;lt;property name="fred.bob.sammy" value="123" /&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;foo&lt;/code&gt; bean有个&lt;code&gt;fred&lt;/code&gt;属性，此属性有个&lt;code&gt;bob&lt;/code&gt;属性，而&lt;code&gt;bob&lt;/code&gt;属性又有个&lt;code&gt;sammy&lt;/code&gt;属性，最后把&lt;code&gt;sammy&lt;/code&gt;属性设置为&lt;code&gt;123&lt;/code&gt;。为了让此定义能工作， &lt;code&gt;foo&lt;/code&gt;的&lt;code&gt;fred&lt;/code&gt;属性及&lt;code&gt;fred&lt;/code&gt;的&lt;code&gt;bob&lt;/code&gt;属性在bean被构造后都必须非空，否则将抛出&lt;code&gt;NullPointerException&lt;/code&gt;异常。&lt;/p&gt; 
&lt;span id="OSC_h3_23"&gt;&lt;/span&gt;
&lt;h3&gt;3. 使用&lt;code&gt;depends-on&lt;/code&gt;&lt;/h3&gt; 
&lt;p&gt;多数情况下，一个bean对另一个bean的依赖最简单的做法就是将一个bean设置为另外一个bean的属性。在xml配置文件中最常见的就是使用 &lt;a rel="nofollow"&gt;&lt;code&gt;&amp;lt;ref/&amp;gt;&lt;/code&gt;元素&lt;/a&gt;。在少数情况下，有时候bean之间的依赖关系并不是那么的直接（例如，当类中的静态块的初始化被时，如数据库驱动的注册）。&lt;code&gt;depends-on&lt;/code&gt;属性可以用于当前bean初始化之前显式地强制一个或多个bean被初始化。下面的例子中使用了&lt;code&gt;depends-on&lt;/code&gt;属性来指定一个bean的依赖。&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="beanOne" class="ExampleBean" depends-on="&lt;strong&gt;manager&lt;/strong&gt;"/&amp;gt;

&amp;lt;bean id="&lt;strong&gt;manager&lt;/strong&gt;" class="ManagerBean" /&amp;gt;&lt;/pre&gt; 
&lt;p&gt;若需要表达对多个bean的依赖，可以在&lt;code&gt;'depends-on'&lt;/code&gt;中将指定的多个bean名字用分隔符进行分隔，分隔符可以是逗号、空格及分号等。下面的例子中使用了&lt;code&gt;'depends-on'&lt;/code&gt;来表达对多个bean的依赖。&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao"&amp;gt;
  &amp;lt;property name="manager" ref="manager" /&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id="manager" class="ManagerBean" /&amp;gt;
&amp;lt;bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" /&amp;gt;&lt;/pre&gt; 
&lt;span id="OSC_h3_24"&gt;&lt;/span&gt;
&lt;h3&gt;注意&lt;/h3&gt; 
&lt;p&gt;“&lt;code&gt;depends-on&lt;/code&gt;”属性不仅用来指定初始化时的依赖，同时也用来指定相应的销毁时的依赖（该依赖只针对&lt;a rel="nofollow"&gt;singleton&lt;/a&gt;bean）。&lt;code&gt;depends-on&lt;/code&gt;属性中指定的依赖bean会在相关bean销毁之前被销毁，从而可以让用户控制销毁顺序。&lt;/p&gt; 
&lt;span id="OSC_h3_25"&gt;&lt;/span&gt;
&lt;h3&gt;3.4. 延迟初始化bean&lt;/h3&gt; 
&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;实现的默认行为就是在启动时将所有&lt;code&gt;singleton&lt;/code&gt; bean提前进行实例化。提前实例化意味着作为初始化过程的一部分，&lt;code&gt;ApplicationContext&lt;/code&gt;实例会创建并配置所有的&lt;a rel="nofollow"&gt;singleton&lt;/a&gt; bean。通常情况下这是件&lt;em&gt;好事&lt;/em&gt;，因为这样在配置中的任何错误就会即刻被发现（否则的话可能要花几个小时甚至几天）。&lt;/p&gt; 
&lt;p&gt;有时候这种默认处理可能并&lt;em&gt;不是&lt;/em&gt;你想要的。如果你不想让一个singleton bean在&lt;code&gt;ApplicationContext&lt;/code&gt;初始化时被提前实例化，那么可以将bean设置为延迟实例化。一个延迟初始化bean将告诉IoC 容器是在启动时还是在第一次被用到时实例化。&lt;/p&gt; 
&lt;p&gt;在XML配置文件中，延迟初始化将通过&lt;code&gt;&amp;lt;bean/&amp;gt;&lt;/code&gt;元素中的&lt;code&gt;lazy-init&lt;/code&gt;属性来进行控制。例如：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="lazy" class="com.foo.ExpensiveToCreateBean" &lt;strong&gt;lazy-init="true"&lt;/strong&gt;/&amp;gt;

&amp;lt;bean name="not.lazy" class="com.foo.AnotherBean"/&amp;gt;&lt;/pre&gt; 
&lt;p&gt;当&lt;code&gt;ApplicationContext&lt;/code&gt;实现加载上述配置时，设置为&lt;code&gt;lazy&lt;/code&gt;的bean将&lt;em&gt;不会&lt;/em&gt;在&lt;code&gt;ApplicationContext&lt;/code&gt;启动时提前被实例化，而&lt;code&gt;not.lazy&lt;/code&gt;却会被提前实例化。&lt;/p&gt; 
&lt;p&gt;需要说明的是，如果一个bean被设置为延迟初始化，而另一个非延迟初始化的singleton bean依赖于它，那么当&lt;code&gt;ApplicationContext&lt;/code&gt;提前实例化singleton bean时，它必须也确保所有上述singleton 依赖bean也被预先初始化，当然也包括设置为延迟实例化的bean。因此，如果Ioc容器在启动的时候创建了那些设置为延迟实例化的bean的实例，你也不要觉得奇怪，因为那些延迟初始化的bean可能在配置的某个地方被注入到了一个非延迟初始化singleton bean里面。&lt;/p&gt; 
&lt;p&gt;在容器层次上通过在&lt;code&gt;&amp;lt;beans/&amp;gt;&lt;/code&gt;元素上使用&lt;code&gt;'default-lazy-init'&lt;/code&gt;属性来控制延迟初始化也是可能的。如下面的配置：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;beans default-lazy-init="true"&amp;gt;
    &lt;em&gt;&amp;lt;!-- no beans will be pre-instantiated... --&amp;gt;&lt;/em&gt;
&amp;lt;/beans&amp;gt;&lt;/pre&gt; 
&lt;span id="OSC_h3_26"&gt;&lt;/span&gt;
&lt;h3&gt;3.5. 自动装配（autowire）协作者&lt;/h3&gt; 
&lt;p&gt;Spring IoC容器可以&lt;em&gt;自动装配（autowire）&lt;/em&gt;相互协作bean之间的关联关系。因此，如果可能的话，可以自动让Spring通过检查&lt;code&gt;BeanFactory&lt;/code&gt;中的内容，来替我们指定bean的协作者（其他被依赖的bean）。autowire一共有五种类型。由于autowire可以针对单个bean进行设置，因此可以让有些bean使用autowire，有些bean不采用。autowire的方便之处在减少或者消除属性或构造器参数的设置，这样可以给我们的配置文件减减肥！[&lt;a rel="nofollow"&gt;2&lt;/a&gt;] 在xml配置文件中，可以在&lt;code&gt;&amp;lt;bean/&amp;gt;&lt;/code&gt;元素中使用autowire属性指定:&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;表 3.2. Autowiring modes&lt;/strong&gt;&lt;/p&gt; 
&lt;table border="1"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th&gt;模式&lt;/th&gt; 
   &lt;th&gt;说明&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt;no&lt;/td&gt; 
   &lt;td&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;byName&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;根据属性名自动装配。此选项将检查容器并根据名字查找与属性完全一致的bean，并将其与属性自动装配。例如，在bean定义中将autowire设置为by name，而该bean包含&lt;em&gt;master&lt;/em&gt;属性（同时提供&lt;em&gt;setMaster(..)&lt;/em&gt;方法），Spring就会查找名为&lt;code&gt;master&lt;/code&gt;的bean定义，并用它来装配给master属性。&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;byType&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;如果容器中存在一个与指定属性类型相同的bean，那么将与该属性自动装配。如果存在多个该类型的bean，那么将会抛出异常，并指出不能使用&lt;em&gt;byType&lt;/em&gt;方式进行自动装配。若没有找到相匹配的bean，则什么事都不发生，属性也不会被设置。如果你不希望这样，那么可以通过设置&lt;code&gt;dependency-check="objects"&lt;/code&gt;让Spring抛出异常。&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;constructor&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;与&lt;em&gt;byType&lt;/em&gt;的方式类似，不同之处在于它应用于构造器参数。如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;autodetect&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;通过bean类的自省机制（introspection）来决定是使用&lt;em&gt;constructor&lt;/em&gt;还是&lt;em&gt;byType&lt;/em&gt;方式进行自动装配。如果发现默认的构造器，那么将使用&lt;em&gt;byType&lt;/em&gt;方式。&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;如果直接使用&lt;code&gt;property&lt;/code&gt;和&lt;code&gt;constructor-arg&lt;/code&gt;注入依赖的话，那么将&lt;code&gt;总是&lt;/code&gt;覆盖自动装配。而且目前也不支持&lt;em&gt;简单&lt;/em&gt;类型的自动装配，这里所说的简单类型包括基本类型、&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Class&lt;/code&gt;以及简单类型的数组（这一点已经被设计，将考虑作为一个&lt;em&gt;功能&lt;/em&gt;提供）。&lt;em&gt;byType&lt;/em&gt;和&lt;em&gt;constructor&lt;/em&gt;自动装配模式也可用于数组和指定类型的集合。在这种情况下容器中的&lt;em&gt;所有&lt;/em&gt;匹配的自动装配对象将被用于满足各种依赖。对于key值类型为 &lt;code&gt;String&lt;/code&gt;的强类型Map也可以被自动装配。一个自动装配的Map的value值将由所匹配类型的bean所填充。而Map的key值则是相应的bean的名字。&lt;/p&gt; 
&lt;p&gt;自动装配还可以与依赖检查结合使用，这样依赖检查将在自动装配完成之后被执行。&lt;/p&gt; 
&lt;p&gt;理解自动装配的优缺点是很重要的。其中优点包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;自动装配能显著减少配置的数量。不过，采用bean模板（见&lt;a rel="nofollow"&gt;这里&lt;/a&gt;）也可以达到同样的目的。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;自动装配可以使配置与java代码同步更新。例如，如果你需要给一个java类增加一个依赖，那么该依赖将被自动实现而不需要修改配置。因此强烈推荐在开发过程中采用自动装配，而在系统趋于稳定的时候改为显式装配的方式。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;自动装配的一些缺点：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;尽管自动装配比显式装配更神奇，但是，正如上面所提到的，Spring会尽量避免在装配不明确的时候进行猜测，因为装配不明确可能出现难以预料的结果，而且Spring所管理的对象之间的关联关系也不再能清晰的进行文档化。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;对于那些根据Spring配置文件生成文档的工具来说，自动装配将会使这些工具没法生成依赖信息。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;另一个问题需要注意的是，当根据类型进行自动装配的时候，容器中可能存在多个bean定义跟自动装配的setter方法和构造器参数类型匹配。虽然对于数组、集合以及Map，不存在这个问题，但是对于单值依赖来说，就会存在模棱两可的问题。如果bean定义不唯一，装配时就会抛出异常，面对这种场景我们有几个方案进行选择：第一个方案就是弃自动装配而改用显式装配；第二个方案就是在bean定义中通过设置&lt;code&gt;'autowire-candidate'&lt;/code&gt;属性为&lt;code&gt;'false'&lt;/code&gt;来将该bean排除在自动装配候选名单之外（详情见接下来的章节）；第三个方案是通过在bean定义中设置&lt;code&gt;'primary'&lt;/code&gt;属性为&lt;code&gt;'true'&lt;/code&gt;来将该bean设置为&lt;em&gt;首选&lt;/em&gt;自动装配bean。最后，对于使用Java 5的用户来说，可能会使用注解的形式来配置bean，关于这方面的内容可见&lt;a rel="nofollow"&gt;第 3.11 节 “基于注解（Annotation-based）的配置”&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;但决定是否使用自动装配式时，没有绝对的对错。考虑项目的实际是最好的办法。比如项目通常不使用自动装配，那么使用它来仅仅装配2个bean定义是很让人困惑的。&lt;/p&gt; 
&lt;span id="OSC_h4_27"&gt;&lt;/span&gt;
&lt;h4&gt;3.5.1. 将bean排除在自动装配之外&lt;/h4&gt; 
&lt;p&gt;你也可以针对单个bean设置其是否为被自动装配对象。当采用XML格式配置bean时，&lt;code&gt;&amp;lt;bean/&amp;gt;&lt;/code&gt;元素的 &lt;code&gt;autowire-candidate&lt;/code&gt;属性可被设为&lt;code&gt;false&lt;/code&gt;，这样容器在查找自动装配对象时将不考虑该bean。&lt;/p&gt; 
&lt;p&gt;另一个做法就是使用对bean名字进行模式匹配来对自动装配进行限制。其做法是在&lt;code&gt;&amp;lt;beans/&amp;gt;&lt;/code&gt;元素的&lt;code&gt;'default-autowire-candidates'&lt;/code&gt;属性中进行设置。比如，将自动装配限制在名字以&lt;em&gt;'Repository'&lt;/em&gt;结尾的bean，那么可以设置为"*Repository“。对于多个匹配模式则可以使用逗号进行分隔。注意，如果在bean定义中的&lt;code&gt;'autowire-candidate'&lt;/code&gt;属性显式的设置为&lt;code&gt;'true'&lt;/code&gt; 或 &lt;code&gt;'false'&lt;/code&gt;，那么该容器在自动装配的时候优先采用该属性的设置，而模式匹配将不起作用。&lt;/p&gt; 
&lt;p&gt;对于那些从来就不会被其它bean采用自动装配的方式来注入的bean而言，这是有用的。不过这并不意味着被排除的bean自己就不能使用自动装配来注入其他bean，它是可以的，或者更准确地说，应该是它不会被考虑作为其他bean自动装配的候选者。&lt;/p&gt; 
&lt;span id="OSC_h3_28"&gt;&lt;/span&gt;
&lt;h3&gt;3.6. 依赖检查&lt;/h3&gt; 
&lt;p&gt;Spring除了能对容器中bean的依赖设置进行检查外，还可以检查bean定义中实际属性值的设置，当然也包括采用自动装配方式设置属性值的检查。&lt;/p&gt; 
&lt;p&gt;当需要确保bean的所有属性值（或者属性类型）被正确设置的时候，那么这个功能会非常有用。当然，在很多情况下，bean类的某些属性会具有默认值，或者有些属性并不会在所有场景下使用，因此这项功能会存在一定的局限性。就像自动装配一样，依赖检查也可以针对每一个bean进行设置。依赖检查默认为&lt;em&gt;not&lt;/em&gt;，它有几种不同的使用模式，在xml配置文件中，可以在bean定义中为&lt;code&gt;dependency-check&lt;/code&gt;属性使用以下几种值：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;表 3.3. 依赖检查方式&lt;/strong&gt;&lt;/p&gt; 
&lt;table border="1"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th&gt;模式&lt;/th&gt; 
   &lt;th&gt;说明&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt;none&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;没有依赖检查，如果bean的属性没有值的话可以不用设置。&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;simple&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;对于原始类型及集合（除协作者外的一切东西）执行依赖检查&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;object&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;仅对协作者执行依赖检查&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;all&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;对协作者，原始类型及集合执行依赖检查&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;p&gt;假若你在使用Java 5，可以采用源代码级的注解（annotations）来进行配置，关于这方面的内容可以在&lt;a rel="nofollow"&gt;第 25.3.1 节 “@&lt;code&gt;Required&lt;/code&gt;”&lt;/a&gt;这一节找到。&lt;/p&gt; 
&lt;span id="OSC_h3_29"&gt;&lt;/span&gt;
&lt;h3&gt;3.7. 方法注入&lt;/h3&gt; 
&lt;p&gt;在大部分情况下，容器中的bean都是&lt;a rel="nofollow"&gt;singleton&lt;/a&gt;类型的。如果一个singleton bean要引用另外一个singleton bean，或者一个非singleton bean要引用另外一个非singleton bean时，通常情况下将一个bean定义为另一个bean的property值就可以了。不过对于具有不同生命周期的bean来说这样做就会有问题了，比如在调用一个singleton类型bean A的某个方法时，需要引用另一个非singleton（prototype）类型的bean B，对于bean A来说，容器只会创建一次，这样就没法在需要的时候每次让容器为bean A提供一个新的的bean B实例。&lt;/p&gt; 
&lt;p&gt;上述问题的一个解决办法就是放弃控制反转。通过实现&lt;code&gt;BeanFactoryAware&lt;/code&gt;接口（见&lt;a rel="nofollow"&gt;这里&lt;/a&gt;）让bean A能够感知bean 容器，并且在需要的时候通过使用&lt;code&gt;getBean("B")&lt;/code&gt;方式（见&lt;a rel="nofollow"&gt;这里&lt;/a&gt;）向容器请求一个新的bean B实例。看下下面这个例子，其中故意使用了这种方法：&lt;/p&gt; 
&lt;pre&gt;&lt;em&gt;// a class that uses a stateful Command-style class to perform some processing&lt;/em&gt;
package fiona.apple;

&lt;em&gt;// lots of Spring-API imports&lt;/em&gt;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;

public class CommandManager implements BeanFactoryAware {

   private BeanFactory beanFactory;

   public Object process(Map commandState) {
      &lt;em&gt;// grab a new instance of the appropriate &lt;code&gt;Command&lt;/code&gt;&lt;/em&gt;
      Command command = createCommand();
      &lt;em&gt;// set the state on the (hopefully brand new) &lt;code&gt;Command&lt;/code&gt; instance&lt;/em&gt;
      command.setState(commandState);
      return command.execute();
   }

   &lt;em&gt;// the &lt;code&gt;Command&lt;/code&gt; returned here could be an implementation that executes asynchronously, or whatever&lt;/em&gt;
   protected Command createCommand() {
      return (Command) this.beanFactory.getBean("command"); &lt;em&gt;// notice the Spring API dependency&lt;/em&gt;
   }

   public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
   }
}&lt;/pre&gt; 
&lt;p&gt;上面的例子显然不是最好的，因为业务代码和Spring Framework产生了耦合。方法注入，作为Spring IoC容器的一种高级特性，可以以一种干净的方法来处理这种情况。&lt;/p&gt; 
&lt;span id="OSC_h4_30"&gt;&lt;/span&gt;
&lt;h4&gt;3.7.1. Lookup方法注入&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;这究竟是不是方法注入……&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;有点像Tapestry 4.0的页面，写上&lt;code&gt;abstract&lt;/code&gt;属性，Tapestry会在运行时用具体实现将其覆盖。&lt;/p&gt; 
&lt;p&gt;在你可以了解更过关于方法注入动机的内容。&lt;/p&gt; 
&lt;p&gt;Lookup方法注入利用了容器的覆盖&lt;em&gt;受容器管理的bean&lt;/em&gt;方法的能力，从而返回指定名字的bean实例。在上述场景中，Lookup方法注入适用于原型bean。Lookup方法注入的内部机制是Spring利用了CGLIB库在运行时生成二进制代码功能，通过动态创建Lookup方法bean的子类而达到复写Lookup方法的目的。&lt;/p&gt; 
&lt;p&gt;如果你看下上个代码段中的代码(&lt;code&gt;CommandManager&lt;/code&gt;类)，Spring容器动态覆盖了&lt;code&gt;createCommand()&lt;/code&gt;方法的实现。你的&lt;code&gt;CommandManager&lt;/code&gt;类不会有一点对Spring的依赖，在下面这个例子中也是一样的：&lt;/p&gt; 
&lt;pre&gt;package fiona.apple;

&lt;em&gt;// no more Spring imports! &lt;/em&gt;

public abstract class CommandManager {

   public Object process(Object commandState) {
      &lt;em&gt;// grab a new instance of the appropriate &lt;code&gt;Command&lt;/code&gt; interface&lt;/em&gt;
      Command command = createCommand();
      &lt;em&gt;// set the state on the (hopefully brand new) &lt;code&gt;Command&lt;/code&gt; instance&lt;/em&gt;
      command.setState(commandState);
      return command.execute();
   }

    &lt;em&gt;// okay... but where is the implementation of this method?&lt;/em&gt;
   protected abstract Command createCommand();
}&lt;/pre&gt; 
&lt;p&gt;在包含被注入方法的客户类中(此处是&lt;code&gt;CommandManager&lt;/code&gt;)，此方法的定义必须按以下形式进行：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;public|protected&amp;gt; [abstract] &amp;lt;return-type&amp;gt; theMethodName(&lt;em&gt;no-arguments&lt;/em&gt;);&lt;/pre&gt; 
&lt;p&gt;如果方法是&lt;code&gt;抽象&lt;/code&gt;的，动态生成的子类会实现该方法。否则，动态生成的子类会覆盖类里的具体方法。让我们来看个例子：&lt;/p&gt; 
&lt;pre&gt;&lt;em&gt;&amp;lt;!-- a stateful bean deployed as a prototype (non-singleton) --&amp;gt;&lt;/em&gt;
&amp;lt;bean id="command" class="fiona.apple.AsyncCommand" scope="prototype"&amp;gt;
  &lt;em&gt;&amp;lt;!-- inject dependencies here as required --&amp;gt;&lt;/em&gt;
&amp;lt;/bean&amp;gt;

&lt;em&gt;&amp;lt;!-- &lt;code&gt;commandProcessor&lt;/code&gt; uses &lt;code&gt;statefulCommandHelper&lt;/code&gt; --&amp;gt;&lt;/em&gt;
&amp;lt;bean id="commandManager" class="fiona.apple.CommandManager"&amp;gt;
  &amp;lt;lookup-method name="createCommand" bean="command"/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt; 
&lt;p&gt;在上面的例子中，标识为&lt;em&gt;commandManager&lt;/em&gt;的bean在需要一个新的&lt;em&gt;command&lt;/em&gt; bean实例时，会调用&lt;code&gt;createCommand&lt;/code&gt;方法。重要的一点是，必须将&lt;code&gt;command&lt;/code&gt;部署为prototype。当然也可以指定为&lt;a rel="nofollow"&gt;singleton&lt;/a&gt;，如果是这样的话，那么每次将返回相同的&lt;code&gt;command&lt;/code&gt; bean实例！&lt;/p&gt; 
&lt;p&gt;请注意，为了让这个动态子类得以正常工作，需要把CGLIB的jar文件放在classpath里。另外，Spring容器要子类化的类不能是&lt;code&gt;final&lt;/code&gt;的，要覆盖的方法也不能是&lt;code&gt;final&lt;/code&gt;的。同样的，要测试一个包含&lt;code&gt;抽象&lt;/code&gt;方法的类也稍微有些不同，你需要自己编写它的子类提供该&lt;code&gt;抽象&lt;/code&gt;方法的桩实现。最后，作为方法注入目标的bean不能是序列化的(serialized)。&lt;/p&gt; 
&lt;span id="OSC_h3_31"&gt;&lt;/span&gt;
&lt;h3&gt;提示&lt;/h3&gt; 
&lt;p&gt;有兴趣的读者也许已经发现&lt;code&gt;ServiceLocatorFactoryBean&lt;/code&gt;(在&lt;code&gt;org.springframework.beans.factory.config&lt;/code&gt;包里)的用法和&lt;code&gt;ObjectFactoryCreatingFactoryBean&lt;/code&gt;的有些相似，不同的是它允许你指定自己的lookup接口，不一定非要用Spring的lookup接口，比如&lt;code&gt;ObjectFactory&lt;/code&gt;。要详细了解这种方法请参考&lt;code&gt;ServiceLocatorFactoryBean&lt;/code&gt;的Javadocs(它&lt;em&gt;的确&lt;/em&gt;减少了对Spring的耦合)。&lt;/p&gt; 
&lt;span id="OSC_h4_32"&gt;&lt;/span&gt;
&lt;h4&gt;3.7.2. 自定义方法的替代方案&lt;/h4&gt; 
&lt;p&gt;比起Lookup 方法注入来，还有一种很少用到的方法注入形式，该注入能使用bean的另一个方法实现去替换自定义的方法。除非你真的需要该功能，否则可以略过本节。&lt;/p&gt; 
&lt;p&gt;当使用基于XML配置元数据文件时，可以在bean定义中使用&lt;code&gt;replaced-method&lt;/code&gt;元素来达到用另一个方法来取代已有方法的目的。考虑下面的类，我们将覆盖computeValue方法：&lt;/p&gt; 
&lt;pre&gt;public class MyValueCalculator {

  public String computeValue(String input) {
    &lt;em&gt;// some real code...&lt;/em&gt;
  }

  &lt;em&gt;// some other methods...&lt;/em&gt;

}&lt;/pre&gt; 
&lt;p&gt;实现&lt;code&gt;org.springframework.beans.factory.support.MethodReplacer&lt;/code&gt;接口的类提供了新的方法定义。&lt;/p&gt; 
&lt;pre&gt;&lt;em&gt;/** meant to be used to override the existing &lt;code&gt;computeValue(String)&lt;/code&gt;
    implementation in &lt;code&gt;MyValueCalculator&lt;/code&gt;
  */&lt;/em&gt;
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        &lt;em&gt;// get the input value, work with it, and return a computed result&lt;/em&gt;
        String input = (String) args[0];
        ... 
        return ...;
    }
}&lt;/pre&gt; 
&lt;p&gt;下面的bean定义中指定了要配置的原始类和将要覆写的方法：&lt;/p&gt; 
&lt;pre&gt;&amp;lt;bean id="myValueCalculator class="x.y.z.MyValueCalculator"&amp;gt;
  &lt;em&gt;&amp;lt;!-- arbitrary method replacement --&amp;gt;&lt;/em&gt;
  &amp;lt;replaced-method name="computeValue" replacer="replacementComputeValue"&amp;gt;
    &amp;lt;arg-type&amp;gt;String&amp;lt;/arg-type&amp;gt;
  &amp;lt;/replaced-method&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/&amp;gt;&lt;/pre&gt; 
&lt;p&gt;在&lt;code&gt;&amp;lt;replaced-method/&amp;gt;&lt;/code&gt;元素内可包含一个或多个&lt;code&gt;&amp;lt;arg-type/&amp;gt;&lt;/code&gt;元素，这些元素用来标明被覆写的方法签名。只有被覆写（override）的方法存在重载（overload）的情况（同名的多个方法变体）才会使用方法签名。为了方便，参数的类型字符串可以采用全限定类名的简写。例如，下面的字符串都表示参数类型为&lt;code&gt;java.lang.String&lt;/code&gt;。&lt;/p&gt; 
&lt;pre&gt;java.lang.String
    String
    Str&lt;/pre&gt; 
&lt;p&gt;参数的个数通常足够用来区别每个可能的选择，这个捷径能减少很多键盘输入的工作，它允许你只输入最短的匹配参数类型的字符串。&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt; 
&lt;hr/&gt; 
&lt;p&gt; &lt;/p&gt;                    &lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>联合国海洋法公约：附件七 仲 裁
        -  junanhonglei
        的个人空间 - 开源中国社区</title><link>http://my.oschina.net/cppblog/blog/710799</link><description>&lt;div class="BlogContent"&gt;
                    &lt;span id="OSC_h2_1"&gt;&lt;/span&gt;
&lt;h2&gt;附件七 仲 裁&lt;/h2&gt; 
&lt;p&gt;　　第一条　程序的提起&lt;/p&gt; 
&lt;p&gt;　　在第十五部分限制下，争端任何一方可向争端他方发出书面通知，将争端提交本附件所规定的仲裁程序。通知应附有一份关于其权利主张及该权利主张所依据的理由的说明。&lt;/p&gt; 
&lt;p&gt;　　第二条　仲裁员名单&lt;/p&gt; 
&lt;p&gt;　　1. 联合国秘书长应编制并保持一份仲裁员名单。每一缔约国应有权提名四名仲裁员，每名仲裁员均应在海洋事务方面富有经验并享有公平、才干和正直的最高声誉。这样提名的人员的姓名应构成该名单。&lt;/p&gt; 
&lt;p&gt;　　2. 无论何时如果一个缔约国提名的仲裁员在这样构成的名单内少于四名，该缔约国应有权按需要提名增补。&lt;/p&gt; 
&lt;p&gt;　　3. 仲裁员经提名缔约国撤回前仍应列在名单内，但被撤回的仲裁员仍应继续在被指派服务的任何仲裁法庭中工作，直到该仲裁法庭处理中的任何程序完成时为止。&lt;/p&gt; 
&lt;p&gt;　　第三条　仲裁法庭的组成&lt;/p&gt; 
&lt;p&gt;　　为本附件所规定程序的目的，除非争端各方另有协议，仲裁法庭应依下列规定组成:&lt;/p&gt; 
&lt;p&gt;　　(a) 在(g)项限制下，仲裁法庭应由仲裁员五人组成。&lt;/p&gt; 
&lt;p&gt;　　(b) 提起程序的一方应指派一人，最好从本附件第二条所指名单中选派，并可为其本国国民。这种指派应列入本附件第一条所指的通知。&lt;/p&gt; 
&lt;p&gt;　　(c) 争端他方应在收到本附件第一条所指通知三十天内指派一名仲裁员，最好从名单人选派，并可为其国民。如在该期限内未作出指派，提起程序的一方，可在该&lt;/p&gt; 
&lt;p&gt;　　期限届满两星期内，请求按照(e)项作出指派。&lt;/p&gt; 
&lt;p&gt;　　(d) 另三名仲裁员应由当事各方间以协议指派。他们最好从名单中选派，并应为第三国国民，除非各方另有协议。争端各方应从这三名仲裁员中选派一人为仲裁法庭庭长。如果在收到本附件第一条所指通知后六十天内，各方未能就应以协议指派的仲裁法庭一名或一名以上仲裁员的指派达成协议，或未能就指派庭长达成协议， 则经争端一方请示，所余指派应按照(e)项作出。这种请示应于上述六十天期间届满后两星期作出。&lt;/p&gt; 
&lt;p&gt;　　(e) 除非争端各方协议将本条(c)和(d)项规定的任何指派交由争端各方选定的某一人士或第三国作出，应由国际海洋法法庭庭长作出必要的指派。如果庭长不能依据本项办理，或为争端一方的国民，这种指派应由可以担任这项工作并且不是争端任何一方国民的国际海洋法法庭年资次深法官作出。本项所指的指派，应于收到请示后三十天期间内，在与当事双方协商后，从本附件第二条所指名单中作出。这样指派的仲裁员应属不同国籍，且不得为争端任何一方的工作人员，或其境内的通常居民或其国民。&lt;/p&gt; 
&lt;p&gt;　　(f) 任何出缺应按照原来的指派方法补缺。&lt;/p&gt; 
&lt;p&gt;　　(g) 利害关系相同的争端各方，应通过协议共同指派一名仲裁员。如果争端若干方利害关系不同，或对彼此是否利害关系相同，意见不一致，则争端每一方应指派一名仲裁员。由争端各方分别指派的仲裁员，其人数应始终比由争端各方共同指派的仲裁员少一人。&lt;/p&gt; 
&lt;p&gt;　　(h) 对于涉及两个以上争端各方的争端，应在最大可能范围内适用(a)至(f) 项的规定。&lt;/p&gt; 
&lt;p&gt;　　第四条　仲裁法庭职务的执行&lt;/p&gt; 
&lt;p&gt;　　依据本附件第三条组成的仲裁法庭，应按照本附件及本公约的其他规定执行职务。&lt;/p&gt; 
&lt;p&gt;　　第五条　程序&lt;/p&gt; 
&lt;p&gt;　　除非争端各方另有协议，仲裁法庭应确定其自己的程序，保证争端每一方有陈述意见和提出其主张的充分机会。&lt;/p&gt; 
&lt;p&gt;　　第六条　争端各方的职责&lt;/p&gt; 
&lt;p&gt;　　争端各方应便利仲裁法庭的工作，特别应按照其本国法律并用一切可用的方法:&lt;/p&gt; 
&lt;p&gt;　　(a) 向法庭提供一切有关文件、便利和情报;并&lt;/p&gt; 
&lt;p&gt;　　(b) 使法庭在必要时能够传唤证人或专家和收受其证据，并视察同案件有关的地点。&lt;/p&gt; 
&lt;p&gt;　　第七条　开支&lt;/p&gt; 
&lt;p&gt;　　&lt;strong&gt;除非仲裁法庭因案情特殊而另有决定，法庭的开支，包括仲裁员的报酬，应由争端各方平均分担。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;　　第八条　作出裁决所需要的多数&lt;/p&gt; 
&lt;p&gt;　　仲裁法庭的裁决应以仲裁员的过半数票作出。不到半数的仲裁员缺席或弃权， 应不妨碍法庭作出裁决，如果票数相等，庭长应投决定票。&lt;/p&gt; 
&lt;p&gt;　　第九条　不到案&lt;/p&gt; 
&lt;p&gt;　　&lt;strong&gt;如争端一方不出庭或对案件不进行辩护，他方可请示仲裁法庭继续进行程序并作出裁决。争端一方缺席或不对案件进行辩护，应不妨碍程序的进行。仲裁法庭在作出裁决前，必须不但查明对该争端确有管辖权，而且查明所提要求在事实上和法庭上均确有根据。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;　　第十条　裁决书&lt;/p&gt; 
&lt;p&gt;　　仲裁法庭的裁决书应以争端的主题事项为限，并应叙明其所根据的理由。裁决书应载明参与作出裁决的仲裁员姓名以及作出裁决的日期。任何仲裁员均可在裁决书上附加个别意见或不同意见。&lt;/p&gt; 
&lt;p&gt;　　第十一条　裁决的确定性&lt;/p&gt; 
&lt;p&gt;　　&lt;strong&gt;除争端各方事前议定某种上诉程序外，裁决应有确定性，不得上诉，争端各方均应遵守裁决。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;　　第十二条　裁决的解释或执行&lt;/p&gt; 
&lt;p&gt;　　1. 争端各方之间对裁决的解释或执行方式的任何争议，可由任何一方提请作出该裁决的仲裁法庭决定。为此目的，法庭的任何出缺，应按原来指派仲裁员的方法补缺。&lt;/p&gt; 
&lt;p&gt;　　2. 任何这种争执，可由争端所有各方协议，提交第二八七条所规定的另一法院或法庭。&lt;/p&gt; 
&lt;p&gt;　　第十三条　对缔约国以外的实体的适用&lt;/p&gt; 
&lt;p&gt;　　本附件应比照适用于涉及缔约国以外的实体的任何争端。&lt;/p&gt;                    &lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>前端代码高亮
        -  南方公园的个人空间 - 开源中国社区</title><link>http://my.oschina.net/tcyx/blog/710798</link><description>&lt;div class="BlogContent"&gt;
                    &lt;p&gt;前端页面，插入的代码高亮这一效果&lt;br/&gt; 因为用的是ecshop 这一坑货。里面还是老的fckeditor,&lt;br/&gt; 连个插入代码段的功能都没有。&lt;br/&gt; 先是换上了ueditor,&lt;br/&gt; 有了插入代码块功能。&lt;/p&gt; 
&lt;p&gt;但代码并没有高亮呀。。。&lt;br/&gt; 然后就纠结。。。&lt;br/&gt; 碰巧，开源中国的编辑器就是用代码高亮的。。。&lt;br/&gt; 然后，右键，查看元素。。。&lt;br/&gt; 嗯，ckeditor&lt;br/&gt; 然后又弄掉了百度编辑器，换了上ckeditor。&lt;br/&gt; 。。。&lt;br/&gt; 然后。昨不一样。。&lt;br/&gt; 又花费了时间，看了ckeditor用使用。。。&lt;br/&gt; 终于能插入代码段了。&lt;br/&gt; 也有那么一点点，高亮。。。&lt;br/&gt; 本以为成功的时候。。。&lt;br/&gt; 打开前台一看。&lt;br/&gt; 并没有。还是那个丑样。&lt;br/&gt; 。。。&lt;br/&gt; 折折腾腾。&lt;br/&gt; 好吧。&lt;br/&gt; 前端代码高亮。&lt;br/&gt; 只是引入了js和css&lt;br/&gt; 对相应的code 进行匹配替换&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;pre&amp;gt;
     &amp;lt;code class="language-js"&amp;gt;

      var Prism = require('prismjs');

     // The code snippet you want to highlight, as a string
     var code = "var data = 1;";

      // Returns a highlighted HTML string
     var html = Prism.highlight(code, Prism.languages.javascript);

     &amp;lt;/code&amp;gt;
&amp;lt;/pre&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;根据&amp;lt;code class="language-js"&amp;gt;里language相应的语言，高亮js,对其，进行相应的css来进行修饰。&lt;/p&gt;                    &lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>实践HTTP206状态:部分内容和范围请求
        -  baiwengong
        的个人空间 - 开源中国社区</title><link>http://my.oschina.net/u/1176559/blog/710796</link><description>&lt;div class="BlogContent"&gt;&lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>Java线程池使用说明
        -  大陆大陆
        的个人空间 - 开源中国社区</title><link>http://my.oschina.net/u/2533897/blog/710789</link><description>&lt;div class="BlogContent"&gt;
                    &lt;p&gt;&lt;span style="font-family:calibri"&gt;&lt;span style="font-family:华文隶书; font-size:22pt"&gt;Java&lt;/span&gt;&lt;span style="font-family:华文隶书; font-size:22pt"&gt;线程池使用说明&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_1"&gt;&lt;/span&gt;
&lt;h1&gt;&lt;span style="font-family:宋体"&gt;一&lt;/span&gt;&lt;span style="font-family:宋体"&gt;简介&lt;/span&gt;&lt;/h1&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;线程的使用在&lt;/span&gt;&lt;span style="font-family:calibri"&gt;java&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中占有极其重要的地位，在&lt;/span&gt;&lt;span style="font-family:calibri"&gt;jdk1.4&lt;/span&gt;&lt;span style="font-family:宋体"&gt;极其之前的&lt;/span&gt;&lt;span style="font-family:calibri"&gt;jdk&lt;/span&gt;&lt;span style="font-family:宋体"&gt;版本中，关于线程池的使用是极其简陋的。在&lt;/span&gt;&lt;span style="font-family:calibri"&gt;jdk1.5&lt;/span&gt;&lt;span style="font-family:宋体"&gt;之后这一情况有了很大的改观。&lt;/span&gt;&lt;span style="font-family:calibri"&gt;Jdk1.5&lt;/span&gt;&lt;span style="font-family:宋体"&gt;之后加入了&lt;/span&gt;&lt;span style="font-family:calibri"&gt;java.util.concurrent&lt;/span&gt;&lt;span style="font-family:宋体"&gt;包，这个包中主要介绍&lt;/span&gt;&lt;span style="font-family:calibri"&gt;java&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中线程以及线程池的使用。为我们在开发中处理线程的问题提供了非常大的帮助。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt;
&lt;h1&gt;&lt;span style="font-family:宋体"&gt;二：线程池&lt;/span&gt;&lt;/h1&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:宋体"&gt;线程池的作用：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-family:宋体"&gt;&lt;span style="font-size:14px"&gt;线程池作用就是限制系统中执行线程的数量。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;span style="font-family:calibri; font-size:14px"&gt;     &lt;/span&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;根 据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排 队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池 中有等待的工作线程，就可以开始运行了；否则进入等待队列。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;span style="font-family:宋体"&gt;&lt;span style="font-size:14px"&gt;为什么要用线程池:&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;1.&lt;/span&gt;&lt;span style="font-family:宋体"&gt;减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;2.&lt;/span&gt;&lt;span style="font-family:宋体"&gt;可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:courier new"&gt;Java&lt;/span&gt;&lt;span style="font-family:宋体"&gt;里面线程池的顶级接口是&lt;/span&gt;&lt;span style="font-family:courier new"&gt;Executor&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，但是严格意义上讲&lt;/span&gt;&lt;span style="font-family:courier new"&gt;Executor&lt;/span&gt;&lt;span style="font-family:宋体"&gt;并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是&lt;/span&gt;&lt;span style="font-family:courier new"&gt;ExecutorService&lt;/span&gt;&lt;span style="font-family:宋体"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;比较重要的几个类：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="background-color:transparent; width:125.9pt"&gt; &lt;p&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;ExecutorService&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="background-color:transparent; width:300.2pt"&gt; &lt;p&gt;&lt;span style="font-family:宋体; font-size:7.5pt"&gt;真正的线程池接口。&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="background-color:transparent; width:125.9pt"&gt; &lt;p&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;ScheduledExecutorService&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="background-color:transparent; width:300.2pt"&gt; &lt;p&gt;&lt;span style="font-family:宋体; font-size:7.5pt"&gt;能和&lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;Timer/TimerTask&lt;/span&gt;&lt;span style="font-family:宋体; font-size:7.5pt"&gt;类似，解决那些需要任务重复执行的问题。&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="background-color:transparent; width:125.9pt"&gt; &lt;p&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;ThreadPoolExecutor&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="background-color:transparent; width:300.2pt"&gt; &lt;p&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;ExecutorService&lt;/span&gt;&lt;span style="font-family:宋体; font-size:7.5pt"&gt;的默认实现。&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="background-color:transparent; width:125.9pt"&gt; &lt;p&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;ScheduledThreadPoolExecutor&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="background-color:transparent; width:300.2pt"&gt; &lt;p&gt;&lt;span style="font-family:宋体; font-size:7.5pt"&gt;继承&lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span style="font-family:宋体; font-size:7.5pt"&gt;的&lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;ScheduledExecutorService&lt;/span&gt;&lt;span style="font-family:宋体; font-size:7.5pt"&gt;接口实现，周期性任务调度的类实现。&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在&lt;/span&gt;&lt;span style="font-family:verdana"&gt;Executors&lt;/span&gt;&lt;span style="font-family:宋体"&gt;类里面提供了一些静态工厂，生成一些常用的线程池。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style="color:black; font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;1. newSingleThreadExecutor&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;span style="color:black; font-family:宋体"&gt;创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:black; font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;2.&lt;strong&gt;&lt;span style="font-family:courier new"&gt;newFixedThreadPool&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;span style="color:black; font-family:宋体"&gt;创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style="color:black; font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;3. newCachedThreadPool&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;span style="color:black; font-family:宋体"&gt;创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;span style="color:black; font-family:宋体"&gt;那么就会回收部分空闲（&lt;/span&gt;&lt;span style="color:black; font-family:verdana"&gt;60&lt;/span&gt;&lt;span style="color:black; font-family:宋体"&gt;秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说&lt;/span&gt;&lt;span style="color:black; font-family:verdana"&gt;JVM&lt;/span&gt;&lt;span style="color:black; font-family:宋体"&gt;）能够创建的最大线程大小。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:black; font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;4.&lt;strong&gt;&lt;span style="font-family:courier new"&gt;newScheduledThreadPool&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;span style="color:black; font-family:宋体"&gt;创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="color:black; font-family:宋体"&gt;实例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="color:black; font-family:courier new"&gt;1&lt;/span&gt;&lt;span style="color:black; font-family:宋体"&gt;：&lt;/span&gt;&lt;span style="color:black; font-family:courier new"&gt;newSingleThreadExecutor&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:courier new"&gt;MyThread.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="width:426.1pt"&gt; &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;public&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;class&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;MyThread &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;extends&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; Thread {&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;    &lt;/span&gt;&lt;span style="color:#646464; font-family:courier new; font-size:7.5pt"&gt;@Override&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;    &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;public&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;void&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; run() {&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        System.&lt;/span&gt;&lt;em&gt;&lt;span style="color:#0000c0; font-family:courier new; font-size:7.5pt"&gt;out&lt;/span&gt;&lt;/em&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;.println(Thread.&lt;em&gt;currentThread&lt;/em&gt;().getName() + &lt;/span&gt;&lt;span style="color:#2a00ff; font-family:courier new; font-size:7.5pt"&gt;"&lt;/span&gt;&lt;span style="color:#2a00ff; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;span style="color:#2a00ff; font-family:courier new; font-size:7.5pt"&gt;"&lt;/span&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;    }&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;}&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;&lt;span style="color:black; font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;TestSingleThreadExecutor.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="width:426.1pt"&gt; &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;public&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;class&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;TestSingleThreadExecutor {&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;    &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;public&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;static&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;void&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; main(String[] args) {&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        &lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;创建一个可重用固定线程数的线程池&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        ExecutorService pool = Executors.&lt;em&gt; newSingleThreadExecutor&lt;/em&gt;();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        &lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;创建实现了&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;Runnable&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;接口对象，&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;Thread&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;对象当然也实现了&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;Runnable&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;接口&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t1 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t2 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t3 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t4 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t5 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        &lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;将线程放入池中进行执行&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t1);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t2);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t3);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t4);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t5);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        &lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;关闭线程池&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.shutdown();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;    }&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;}&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:宋体"&gt;输出结果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="width:426.1pt"&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-1&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-1&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-1&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-1&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-1&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:courier new"&gt;2&lt;/span&gt;&lt;span style="color:black; font-family:courier new"&gt;newFixedThreadPool&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;TestFixedThreadPool.Java&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="background-color:transparent; width:426.1pt"&gt; &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;public&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;class&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; TestFixedThreadPool {&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;    &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;public&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;static&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;void&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; main(String[] args) {&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        &lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;创建一个可重用固定线程数的线程池&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        ExecutorService pool = Executors.&lt;em&gt;newFixedThreadPool&lt;/em&gt;(2);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        &lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;创建实现了&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;Runnable&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;接口对象，&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;Thread&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;对象当然也实现了&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;Runnable&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;接口&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t1 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t2 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t3 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t4 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t5 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        &lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;将线程放入池中进行执行&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t1);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t2);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t3);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t4);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t5);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        &lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;关闭线程池&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.shutdown();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;    }&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;}&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:宋体"&gt;输出结果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="width:426.1pt"&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-1&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-2&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-1&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-2&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-1&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;3&lt;strong&gt;&lt;span style="color:black; font-family:courier new"&gt; newCachedThreadPool&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;span style="color:black; font-family:courier new"&gt;TestCachedThreadPool.java&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="width:426.1pt"&gt; &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;public&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;class&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; TestCachedThreadPool {&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;    &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;public&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;static&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;void&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; main(String[] args) {&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        &lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;创建一个可重用固定线程数的线程池&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        ExecutorService pool = Executors.&lt;em&gt;newCachedThreadPool&lt;/em&gt;();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        &lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;创建实现了&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;Runnable&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;接口对象，&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;Thread&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;对象当然也实现了&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;Runnable&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;接口&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t1 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t2 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t3 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t4 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        Thread t5 = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; MyThread();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        &lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;将线程放入池中进行执行&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t1);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t2);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t3);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t4);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.execute(t5);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        &lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;关闭线程池&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        pool.shutdown();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;    }&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;}&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;输出结果：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="width:426.1pt"&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-2&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-4&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-3&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-1&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;pool-1-thread-5&lt;/span&gt;&lt;span style="color:black; font-family:宋体; font-size:7.5pt"&gt;正在执行。。。&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;4&lt;strong&gt;&lt;span style="color:black; font-family:courier new"&gt;newScheduledThreadPool&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;TestScheduledThreadPoolExecutor.java&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="width:426.1pt"&gt; &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;public&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;class&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; TestScheduledThreadPoolExecutor {&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;    &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;public&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;static&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;void&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; main(String[] args) {&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        ScheduledThreadPoolExecutor exec = &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; ScheduledThreadPoolExecutor(1);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        exec.scheduleAtFixedRate(&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; Runnable() {&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;每隔一段时间就触发异常&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;                      &lt;/span&gt;&lt;span style="color:#646464; font-family:courier new; font-size:7.5pt"&gt;@Override&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;                      &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;public&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;void&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; run() {&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;                           &lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//throw new RuntimeException();&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;                           System.&lt;/span&gt;&lt;em&gt;&lt;span style="color:#0000c0; font-family:courier new; font-size:7.5pt"&gt;out&lt;/span&gt;&lt;/em&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;.println(&lt;/span&gt;&lt;span style="color:#2a00ff; font-family:courier new; font-size:7.5pt"&gt;"================"&lt;/span&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;                      }&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;                  }, 1000, 5000, TimeUnit.&lt;/span&gt;&lt;em&gt;&lt;span style="color:#0000c0; font-family:courier new; font-size:7.5pt"&gt;MILLISECONDS&lt;/span&gt;&lt;/em&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;        exec.scheduleAtFixedRate(&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;new&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; Runnable() {&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:courier new; font-size:7.5pt"&gt;//&lt;/span&gt;&lt;span style="color:#3f7f5f; font-family:宋体; font-size:7.5pt"&gt;每隔一段时间打印系统时间，证明两者是互不影响的&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;                      &lt;/span&gt;&lt;span style="color:#646464; font-family:courier new; font-size:7.5pt"&gt;@Override&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;                      &lt;/span&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;public&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#7f0055; font-family:courier new; font-size:7.5pt"&gt;void&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt; run() {&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;                           System.&lt;/span&gt;&lt;em&gt;&lt;span style="color:#0000c0; font-family:courier new; font-size:7.5pt"&gt;out&lt;/span&gt;&lt;/em&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;.println(System.&lt;em&gt;nanoTime&lt;/em&gt;());&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;                      }&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;                  }, 1000, 2000, TimeUnit.&lt;/span&gt;&lt;em&gt;&lt;span style="color:#0000c0; font-family:courier new; font-size:7.5pt"&gt;MILLISECONDS&lt;/span&gt;&lt;/em&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;);&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;    }&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;}&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;输出结果&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="width:426.1pt"&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;================&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;8384644549516&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;8386643829034&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;8388643830710&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;================&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;8390643851383&lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;8392643879319&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span style="color:black; font-family:courier new; font-size:7.5pt"&gt;8400643939383&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt;
&lt;h1&gt;&lt;span style="font-family:宋体"&gt;三：&lt;/span&gt;&lt;span style="font-family:calibri"&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span style="font-family:宋体"&gt;详解&lt;/span&gt;&lt;/h1&gt; 
&lt;p&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span style="font-size:10.5pt"&gt;&lt;span style="font-family:宋体"&gt;的完整构造方法的签名是：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;ThreadPoolExecutor&lt;/span&gt;&lt;/strong&gt;&lt;code&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)&lt;/span&gt;&lt;/code&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt; .&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="color:black; font-family:courier new"&gt;corePoolSize&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new"&gt; - &lt;/span&gt;&lt;span style="color:black; font-family:宋体"&gt;池中所保存的线程数，包括空闲线程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="color:black; font-family:courier new"&gt;maximumPoolSize&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new"&gt;-&lt;/span&gt;&lt;span style="color:black; font-family:宋体"&gt;池中允许的最大线程数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="color:black; font-family:courier new"&gt;keepAliveTime&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new"&gt; - &lt;/span&gt;&lt;span style="color:black; font-family:宋体"&gt;当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="color:black; font-family:courier new"&gt;unit&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new"&gt; - keepAliveTime &lt;/span&gt;&lt;span style="color:black; font-family:宋体"&gt;参数的时间单位。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="color:black; font-family:courier new"&gt;workQueue&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new"&gt; - &lt;/span&gt;&lt;span style="color:black; font-family:宋体"&gt;执行前用于保持任务的队列。此队列仅保持由&lt;/span&gt;&lt;span style="color:black; font-family:courier new"&gt; execute&lt;/span&gt;&lt;span style="color:black; font-family:宋体"&gt;方法提交的&lt;/span&gt;&lt;span style="color:black; font-family:courier new"&gt; Runnable&lt;/span&gt;&lt;span style="color:black; font-family:宋体"&gt;任务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="color:black; font-family:courier new"&gt;threadFactory&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new"&gt; - &lt;/span&gt;&lt;span style="color:black; font-family:宋体"&gt;执行程序创建新线程时使用的工厂。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="color:black; font-family:courier new"&gt;handler&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:black; font-family:courier new"&gt; - &lt;/span&gt;&lt;span style="color:black; font-family:宋体"&gt;由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span style="font-family:宋体; font-size:10.5pt"&gt;是&lt;/span&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;Executors&lt;/span&gt;&lt;span style="font-family:宋体; font-size:10.5pt"&gt;类的底层实现。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:10.5pt"&gt;&lt;span style="font-family:宋体"&gt;在&lt;/span&gt;&lt;/span&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;JDK&lt;/span&gt;&lt;span style="font-family:宋体"&gt;&lt;span style="font-size:10.5pt"&gt;帮助文档中，有如此一段话：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;“&lt;/span&gt;&lt;span style="font-size:10.5pt"&gt;&lt;span style="font-family:宋体"&gt;强烈建议程序员使用较为方便的&lt;/span&gt;&lt;/span&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;&lt;code&gt;&lt;span style="font-family:courier new"&gt;Executors&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;span style="font-size:10.5pt"&gt;&lt;span style="font-family:宋体"&gt;工厂方法&lt;/span&gt;&lt;/span&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;&lt;code&gt;&lt;span style="font-family:courier new"&gt;Executors.newCachedThreadPool()&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;span style="font-size:10.5pt"&gt;&lt;span style="font-family:宋体"&gt;（无界线程池，可以进行自动线程回收）、&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;Executors.newFixedThreadPool(int)&lt;/span&gt;&lt;/code&gt;&lt;span style="font-size:10.5pt"&gt;&lt;span style="font-family:宋体"&gt;（固定大小线程池）&lt;/span&gt;&lt;/span&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;&lt;code&gt;&lt;span style="font-family:courier new"&gt;Executors.newSingleThreadExecutor()&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;span style="font-family:宋体"&gt;&lt;span style="font-size:10.5pt"&gt;（单个后台线程）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:10.5pt"&gt;&lt;span style="font-family:宋体"&gt;它们均为大多数使用场景预定义了设置。&lt;/span&gt;&lt;/span&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;”&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-family:宋体"&gt;&lt;span style="font-size:14px"&gt;下面介绍一下几个类的源码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:courier new"&gt;ExecutorService  newFixedThreadPool (int nThreads):&lt;/span&gt;&lt;span style="font-family:宋体"&gt;固定大小线程池。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;可以看到，&lt;/span&gt;&lt;span style="font-family:courier new"&gt;corePoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;和&lt;/span&gt;&lt;span style="font-family:courier new"&gt;maximumPoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;的大小是一样的（实际上，后面会介绍，如果使用无界&lt;/span&gt;&lt;span style="font-family:courier new"&gt;queue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;的话&lt;/span&gt;&lt;span style="font-family:courier new"&gt;maximumPoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;参数是没有意义的），&lt;/span&gt;&lt;span style="font-family:courier new"&gt;keepAliveTime&lt;/span&gt;&lt;span style="font-family:宋体"&gt;和&lt;/span&gt;&lt;span style="font-family:courier new"&gt;unit&lt;/span&gt;&lt;span style="font-family:宋体"&gt;的设值表名什么？&lt;/span&gt;&lt;span style="font-family:courier new"&gt;-&lt;/span&gt;&lt;span style="font-family:宋体"&gt;就是&lt;span style="color:red"&gt;该实现不想&lt;/span&gt;&lt;/span&gt;&lt;span style="color:red; font-family:courier new"&gt;keep alive&lt;/span&gt;&lt;span style="font-family:宋体"&gt;！最后的&lt;/span&gt;&lt;span style="font-family:courier new"&gt;BlockingQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;选择了&lt;/span&gt;&lt;span style="font-family:courier new"&gt;LinkedBlockingQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，&lt;span style="color:red"&gt;该&lt;/span&gt;&lt;/span&gt;&lt;span style="color:red; font-family:courier new"&gt;queue&lt;/span&gt;&lt;span style="color:red; font-family:宋体"&gt;有一个特点，他是无界的&lt;/span&gt;&lt;span style="font-family:宋体"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="width:426.1pt"&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;1.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;public static ExecutorService newFixedThreadPool(int nThreads) {   &lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;2.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;        return new ThreadPoolExecutor(nThreads, nThreads,   &lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;3.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;                                      0L, TimeUnit.MILLISECONDS,   &lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;4.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());   &lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;5.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;    }&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:calibri"&gt;ExecutorService  newSingleThreadExecutor()&lt;/span&gt;&lt;span style="font-family:宋体"&gt;：单线程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="width:426.1pt"&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;1.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;public static ExecutorService newSingleThreadExecutor() {   &lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;2.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;        return new FinalizableDelegatedExecutorService   &lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;3.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            (new ThreadPoolExecutor(&lt;span style="color:#c00000"&gt;1&lt;/span&gt;, &lt;span style="color:#c00000"&gt;1&lt;/span&gt;,   &lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;4.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;                                    0L, TimeUnit.MILLISECONDS,   &lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;5.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;                                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));   &lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;6.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;    }&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:calibri"&gt;ExecutorService newCachedThreadPool()&lt;/span&gt;&lt;span style="font-family:宋体"&gt;：无界线程池，可以进行自动线程回收&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-size:10.5pt"&gt;&lt;span style="font-family:宋体"&gt;这个实现就有意思了。首先是无界的线程池，所以我们可以发现&lt;/span&gt;&lt;/span&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;maximumPoolSize&lt;/span&gt;&lt;span style="font-size:10.5pt"&gt;&lt;span style="font-family:宋体"&gt;为&lt;/span&gt;&lt;/span&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;big big&lt;/span&gt;&lt;span style="font-size:10.5pt"&gt;&lt;span style="font-family:宋体"&gt;。其次&lt;/span&gt;&lt;/span&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;BlockingQueue&lt;/span&gt;&lt;span style="font-size:10.5pt"&gt;&lt;span style="font-family:宋体"&gt;的选择上使用&lt;/span&gt;&lt;/span&gt;&lt;span style="color:red; font-family:courier new; font-size:10.5pt"&gt;SynchronousQueue&lt;/span&gt;&lt;span style="font-size:10.5pt"&gt;&lt;span style="font-family:宋体"&gt;。可能对于该&lt;/span&gt;&lt;/span&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;BlockingQueue&lt;/span&gt;&lt;span style="font-size:10.5pt"&gt;&lt;span style="font-family:宋体"&gt;有些陌生，简单说：该&lt;/span&gt;&lt;/span&gt;&lt;span style="font-family:courier new; font-size:10.5pt"&gt;QUEUE&lt;/span&gt;&lt;span style="font-family:宋体"&gt;&lt;span style="font-size:10.5pt"&gt;中，每个插入操作必须等待另一个线程的对应移除操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="width:426.1pt"&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;1.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;public static ExecutorService newCachedThreadPool() {   &lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;2.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;        return new ThreadPoolExecutor(&lt;span style="color:#c00000"&gt;0&lt;/span&gt;, Integer.MAX_VALUE,   &lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;3.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;                                      60L, TimeUnit.SECONDS,   &lt;/span&gt;&lt;/p&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;4.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;());   &lt;/span&gt;&lt;/p&gt; 
    &lt;ol&gt; 
     &lt;li&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;    }&lt;/span&gt;&lt;/li&gt; 
    &lt;/ol&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;先从&lt;/span&gt;&lt;a href="http://dongxuan.iteye.com/admin/blogs/901659/" rel="nofollow"&gt;&lt;span style="font-family:courier new"&gt;BlockingQueue&lt;/span&gt;&lt;/a&gt;&lt;span style="font-family:courier new"&gt;&amp;lt;&lt;/span&gt;&lt;a href="http://dongxuan.iteye.com/admin/blogs/901659/" rel="nofollow"&gt;&lt;span style="font-family:courier new"&gt;Runnable&lt;/span&gt;&lt;/a&gt;&lt;span style="font-family:courier new"&gt;&amp;gt; workQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;这个入参开始说起。在&lt;/span&gt;&lt;span style="font-family:courier new"&gt;JDK&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中，其实已经说得很清楚了，一共有三种类型的&lt;/span&gt;&lt;span style="font-family:courier new"&gt;queue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;所有&lt;/span&gt;&lt;span style="font-family:courier new"&gt;BlockingQueue &lt;/span&gt;&lt;span style="font-family:宋体"&gt;都可用于传输和保持提交的任务。可以使用此队列与池大小进行交互：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;如果运行的线程少于&lt;/span&gt;&lt;span style="font-family:courier new"&gt; corePoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，则&lt;/span&gt;&lt;span style="font-family:courier new"&gt; Executor&lt;/span&gt;&lt;span style="font-family:宋体"&gt;始终首选添加新的线程，而不进行排队。（&lt;span style="color:red"&gt;如果当前运行的线程小于&lt;/span&gt;&lt;/span&gt;&lt;span style="color:red; font-family:courier new"&gt;corePoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，则任务&lt;span style="color:red"&gt;根本不会存放，添加到&lt;/span&gt;&lt;/span&gt;&lt;span style="color:red; font-family:courier new"&gt;queue&lt;/span&gt;&lt;span style="color:red; font-family:宋体"&gt;中&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，而是&lt;span style="color:red"&gt;直接&lt;/span&gt;抄家伙（&lt;/span&gt;&lt;span style="font-family:courier new"&gt;thread&lt;/span&gt;&lt;span style="font-family:宋体"&gt;）&lt;span style="color:red"&gt;开始运行&lt;/span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;如果运行的线程等于或多于&lt;/span&gt;&lt;span style="font-family:courier new"&gt; corePoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，则&lt;/span&gt;&lt;span style="font-family:courier new"&gt; Executor&lt;/span&gt;&lt;span style="font-family:宋体"&gt;始终&lt;span style="color:red"&gt;首选将请求加入队列&lt;/span&gt;，&lt;strong&gt;&lt;span style="color:red"&gt;而不添加新的线程&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;如果无法将请求加入队列，&lt;span style="color:red"&gt;则创建新的线程&lt;/span&gt;，除非创建此线程超出&lt;/span&gt;&lt;span style="font-family:courier new"&gt; maximumPoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，在这种情况下，任务将被拒绝。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:courier new"&gt;queue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;上的三种类型。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;排队有三种通用策略：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:宋体"&gt;直接提交。&lt;/span&gt;&lt;/strong&gt;&lt;span style="font-family:宋体"&gt;工作队列的默认选项是&lt;/span&gt;&lt;span style="font-family:courier new"&gt; SynchronousQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，它将任务直接提交给线程而不保持它们。在此，&lt;span style="color:red"&gt;如果不存在可用于立即运行任务的线程&lt;/span&gt;，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。&lt;span style="color:red"&gt;直接提交通常要求无界&lt;/span&gt;&lt;/span&gt;&lt;span style="color:red; font-family:courier new"&gt; maximumPoolSizes &lt;/span&gt;&lt;span style="color:red; font-family:宋体"&gt;以避免拒绝新提交的任务&lt;/span&gt;&lt;span style="font-family:宋体"&gt;。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:宋体"&gt;无界队列。&lt;/span&gt;&lt;/strong&gt;&lt;span style="font-family:宋体"&gt;使用无界队列（例如，不具有预定义容量的&lt;/span&gt;&lt;span style="font-family:courier new"&gt; LinkedBlockingQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;）将导致在所有&lt;/span&gt;&lt;span style="font-family:courier new"&gt; corePoolSize &lt;/span&gt;&lt;span style="font-family:宋体"&gt;线程都忙时新任务在队列中等待。这样，&lt;span style="color:red"&gt;创建的线程就不会超过&lt;/span&gt;&lt;/span&gt;&lt;span style="color:red; font-family:courier new"&gt; corePoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;。（因此，&lt;/span&gt;&lt;span style="font-family:courier new"&gt;maximumPoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在&lt;/span&gt;&lt;span style="font-family:courier new"&gt; Web&lt;/span&gt;&lt;span style="font-family:宋体"&gt;页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:宋体"&gt;有界队列。&lt;/span&gt;&lt;/strong&gt;&lt;span style="font-family:宋体"&gt;当使用有限的&lt;/span&gt;&lt;span style="font-family:courier new"&gt; maximumPoolSizes&lt;/span&gt;&lt;span style="font-family:宋体"&gt;时，有界队列（如&lt;/span&gt;&lt;span style="font-family:courier new"&gt; ArrayBlockingQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;）有助于&lt;span style="color:red"&gt;防止资源耗尽&lt;/span&gt;，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低&lt;/span&gt;&lt;span style="font-family:courier new"&gt; CPU &lt;/span&gt;&lt;span style="font-family:宋体"&gt;使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是&lt;/span&gt;&lt;span style="font-family:courier new"&gt; I/O&lt;/span&gt;&lt;span style="font-family:宋体"&gt;边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，&lt;/span&gt;&lt;span style="font-family:courier new"&gt;CPU&lt;/span&gt;&lt;span style="font-family:宋体"&gt;使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。&lt;/span&gt;&lt;span style="font-family:courier new"&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;span style="font-size:14pt"&gt;&lt;span style="font-family:calibri"&gt;BlockingQueue&lt;/span&gt;&lt;/span&gt;&lt;span style="font-family:宋体; font-size:14pt"&gt;的选择。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:宋体"&gt;例子一：使用直接提交策略，也即&lt;/span&gt;&lt;span style="font-family:courier new"&gt;SynchronousQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;首先&lt;/span&gt;&lt;span style="font-family:courier new"&gt;SynchronousQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;是无界的，也就是说他存数任务的能力是没有限制的，但是&lt;span style="color:red"&gt;由于该&lt;/span&gt;&lt;/span&gt;&lt;span style="color:red; font-family:courier new"&gt;Queue&lt;/span&gt;&lt;span style="color:red; font-family:宋体"&gt;本身的特性&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，&lt;strong&gt;在某次添加元素后必须等待其他线程取走后才能继续添加&lt;/strong&gt;。在这里不是核心线程便是新创建的线程，但是我们试想一样下，下面的场景。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;我们使用一下参数构造&lt;/span&gt;&lt;span style="font-family:courier new"&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span style="font-family:宋体"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;1.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;new ThreadPoolExecutor(   &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;2.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            &lt;span style="color:#c00000"&gt;2&lt;/span&gt;, &lt;span style="color:#c00000"&gt;3&lt;/span&gt;, &lt;span style="color:#c00000"&gt;30&lt;/span&gt;, TimeUnit.SECONDS,    &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;3.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            new  SynchronousQueue&amp;lt;Runnable&amp;gt;(),    &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;4.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            new RecorderThreadFactory("CookieRecorderPool"),    &lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            new ThreadPoolExecutor.CallerRunsPolicy()); &lt;/span&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt; &lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;new ThreadPoolExecutor(&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;  2, 3, 30, TimeUnit.SECONDS, &lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;  new SynchronousQueue&amp;lt;Runnable&amp;gt;(), &lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;  new RecorderThreadFactory("CookieRecorderPool"), &lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;  new ThreadPoolExecutor.CallerRunsPolicy());&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:courier new"&gt; &lt;/span&gt;&lt;span style="font-family:宋体"&gt;当核心线程已经有&lt;/span&gt;&lt;span style="font-family:courier new"&gt;2&lt;/span&gt;&lt;span style="font-family:宋体"&gt;个正在运行&lt;/span&gt;&lt;span style="font-family:courier new"&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;此时继续来了一个任务（&lt;/span&gt;&lt;span style="font-family:courier new"&gt;A&lt;/span&gt;&lt;span style="font-family:宋体"&gt;），根据前面介绍的&lt;/span&gt;&lt;span style="font-family:courier new"&gt;“&lt;/span&gt;&lt;span style="font-family:宋体"&gt;如果运行的线程等于或多于&lt;/span&gt;&lt;span style="font-family:courier new"&gt; corePoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，则&lt;/span&gt;&lt;span style="font-family:courier new"&gt; Executor&lt;/span&gt;&lt;span style="font-family:宋体"&gt;始终&lt;span style="color:red"&gt;首选将请求加入队列&lt;/span&gt;，&lt;strong&gt;&lt;span style="color:red"&gt;而不添加新的线程&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;span style="font-family:courier new"&gt;”,&lt;/span&gt;&lt;span style="font-family:宋体"&gt;所以&lt;/span&gt;&lt;span style="font-family:courier new"&gt;A&lt;/span&gt;&lt;span style="font-family:宋体"&gt;被添加到&lt;/span&gt;&lt;span style="font-family:courier new"&gt;queue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;又来了一个任务（&lt;/span&gt;&lt;span style="font-family:courier new"&gt;B&lt;/span&gt;&lt;span style="font-family:宋体"&gt;），且核心&lt;/span&gt;&lt;span style="font-family:courier new"&gt;2&lt;/span&gt;&lt;span style="font-family:宋体"&gt;个线程还没有忙完，&lt;/span&gt;&lt;span style="font-family:courier new"&gt;OK&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，接下来首先尝试&lt;/span&gt;&lt;span style="font-family:courier new"&gt;1&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中描述，但是由于使用的&lt;/span&gt;&lt;span style="font-family:courier new"&gt;SynchronousQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，所以一定无法加入进去。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;此时便满足了上面提到的&lt;/span&gt;&lt;span style="font-family:courier new"&gt;“&lt;/span&gt;&lt;span style="font-family:宋体"&gt;如果无法将请求加入队列，&lt;span style="color:red"&gt;则创建新的线程&lt;/span&gt;，除非创建此线程超出&lt;/span&gt;&lt;span style="font-family:courier new"&gt;maximumPoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，在这种情况下，任务将被拒绝。&lt;/span&gt;&lt;span style="font-family:courier new"&gt;”&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，所以必然会新建一个线程来运行这个任务。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;暂时还可以，但是如果这三个任务都还没完成，连续来了两个任务，第一个添加入&lt;/span&gt;&lt;span style="font-family:courier new"&gt;queue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中，后一个呢？&lt;/span&gt;&lt;span style="font-family:courier new"&gt;queue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中无法插入，而线程数达到了&lt;/span&gt;&lt;span style="font-family:courier new"&gt;maximumPoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，所以只好执行异常策略了。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;所以在使用&lt;/span&gt;&lt;span style="font-family:courier new"&gt;SynchronousQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;通常要求&lt;/span&gt;&lt;span style="font-family:courier new"&gt;maximumPoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;是无界的，这样就可以避免上述情况发生（如果希望限制就直接使用有界队列）。对于使用&lt;/span&gt;&lt;span style="font-family:courier new"&gt;SynchronousQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;的作用&lt;/span&gt;&lt;span style="font-family:courier new"&gt;jdk&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中写的很清楚：&lt;span style="color:red"&gt;此策略可以避免在处理可能具有内部依赖性的请求集时出现锁&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;什么意思？如果你的任务&lt;/span&gt;&lt;span style="font-family:courier new"&gt;A1&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，&lt;/span&gt;&lt;span style="font-family:courier new"&gt;A2&lt;/span&gt;&lt;span style="font-family:宋体"&gt;有内部关联，&lt;/span&gt;&lt;span style="font-family:courier new"&gt;A1&lt;/span&gt;&lt;span style="font-family:宋体"&gt;需要先运行，那么先提交&lt;/span&gt;&lt;span style="font-family:courier new"&gt;A1&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，再提交&lt;/span&gt;&lt;span style="font-family:courier new"&gt;A2&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，当使用&lt;/span&gt;&lt;span style="font-family:courier new"&gt;SynchronousQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;我们可以保证，&lt;/span&gt;&lt;span style="font-family:courier new"&gt;A1&lt;/span&gt;&lt;span style="font-family:宋体"&gt;必定先被执行，在&lt;/span&gt;&lt;span style="font-family:courier new"&gt;A1&lt;/span&gt;&lt;span style="font-family:宋体"&gt;么有被执行前，&lt;/span&gt;&lt;span style="font-family:courier new"&gt;A2&lt;/span&gt;&lt;span style="font-family:宋体"&gt;不可能添加入&lt;/span&gt;&lt;span style="font-family:courier new"&gt;queue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:宋体"&gt;例子二：使用无界队列策略，即&lt;/span&gt;&lt;span style="font-family:courier new"&gt;LinkedBlockingQueue&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;这个就拿&lt;/span&gt;&lt;strong&gt;&lt;span style="font-family:courier new"&gt;newFixedThreadPool&lt;/span&gt;&lt;/strong&gt;&lt;span style="font-family:宋体"&gt;来说，根据前文提到的规则：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;如果运行的线程少于&lt;/span&gt;&lt;span style="font-family:courier new"&gt; corePoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，则&lt;/span&gt;&lt;span style="font-family:courier new"&gt; Executor &lt;/span&gt;&lt;span style="font-family:宋体"&gt;始终首选添加新的线程，而不进行排队。那么当任务继续增加，会发生什么呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;如果运行的线程等于或多于&lt;/span&gt;&lt;span style="font-family:courier new"&gt; corePoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，则&lt;/span&gt;&lt;span style="font-family:courier new"&gt; Executor &lt;/span&gt;&lt;span style="font-family:宋体"&gt;始终首选将请求加入队列，而不添加新的线程。&lt;/span&gt;&lt;span style="font-family:courier new"&gt;OK&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，此时任务变加入队列之中了，那什么时候才会添加新线程呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;如果无法将请求加入队列，则创建新的线程，除非创建此线程超出&lt;/span&gt;&lt;span style="font-family:courier new"&gt; maximumPoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，在这种情况下，任务将被拒绝。这里就很有意思了，可能会出现无法加入队列吗？不像&lt;/span&gt;&lt;span style="font-family:courier new"&gt;SynchronousQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;那样有其自身的特点，对于无界队列来说，总是可以加入的（资源耗尽，当然另当别论）。&lt;span style="color:red"&gt;换句说，永远也不会触发产生新的线程！&lt;/span&gt;&lt;/span&gt;&lt;span style="font-family:courier new"&gt;corePoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;大小的线程数会一直运行，忙完当前的，就从队列中拿任务开始运行。所以要防止任务疯长，比如任务运行的实行比较长，而添加任务的速度远远超过处理任务的时间，而且还不断增加，不一会儿就爆了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:宋体"&gt;例子三：有界队列，使用&lt;/span&gt;&lt;span style="font-family:courier new"&gt;ArrayBlockingQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;这个是最为复杂的使用，所以&lt;/span&gt;&lt;span style="font-family:courier new"&gt;JDK&lt;/span&gt;&lt;span style="font-family:宋体"&gt;不推荐使用也有些道理。与上面的相比，最大的特点便是可以防止资源耗尽的情况发生。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;举例来说，请看如下构造方法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;1.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;new ThreadPoolExecutor(   &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;2.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            &lt;span style="color:#c00000"&gt;2&lt;/span&gt;, &lt;span style="color:#c00000"&gt;4&lt;/span&gt;, &lt;span style="color:#c00000"&gt;30&lt;/span&gt;, TimeUnit.SECONDS,    &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;3.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            new ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(&lt;span style="color:#c00000"&gt;2&lt;/span&gt;),    &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;4.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            new RecorderThreadFactory("CookieRecorderPool"),    &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;5.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            new ThreadPoolExecutor.CallerRunsPolicy());  &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;new ThreadPoolExecutor(&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;    2, 4, 30, TimeUnit.SECONDS, &lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;    new ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(2), &lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;    new RecorderThreadFactory("CookieRecorderPool"), &lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;    new ThreadPoolExecutor.CallerRunsPolicy());&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="color:red; font-family:宋体"&gt;假设，所有的任务都永远无法执行完。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;对于首先来的&lt;/span&gt;&lt;span style="font-family:courier new"&gt;A,B&lt;/span&gt;&lt;span style="font-family:宋体"&gt;来说直接运行，接下来，如果来了&lt;/span&gt;&lt;span style="font-family:courier new"&gt;C,D&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，他们会被放到&lt;/span&gt;&lt;span style="font-family:courier new"&gt;queue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中，如果接下来再来&lt;/span&gt;&lt;span style="font-family:courier new"&gt;E,F&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，则增加线程运行&lt;/span&gt;&lt;span style="font-family:courier new"&gt;E&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，&lt;/span&gt;&lt;span style="font-family:courier new"&gt;F&lt;/span&gt;&lt;span style="font-family:宋体"&gt;。但是如果再来任务，队列无法再接受了，线程数也到达最大的限制了，所以就会使用拒绝策略来处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:arial"&gt;keepAliveTime&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:arial"&gt;jdk&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中的解释是：当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;有点拗口，其实这个不难理解，在使用了&lt;/span&gt;&lt;span style="font-family:arial"&gt;“&lt;/span&gt;&lt;span style="font-family:宋体"&gt;池&lt;/span&gt;&lt;span style="font-family:arial"&gt;”&lt;/span&gt;&lt;span style="font-family:宋体"&gt;的应用中，大多都有类似的参数需要配置。比如数据库连接池，&lt;/span&gt;&lt;span style="font-family:arial"&gt;DBCP&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中的&lt;/span&gt;&lt;span style="font-family:arial"&gt;maxIdle&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，&lt;/span&gt;&lt;span style="font-family:arial"&gt;minIdle&lt;/span&gt;&lt;span style="font-family:宋体"&gt;参数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;什么意思？接着上面的解释，后来向老板派来的工人始终是&lt;/span&gt;&lt;span style="font-family:arial"&gt;“&lt;/span&gt;&lt;span style="font-family:宋体"&gt;借来的&lt;/span&gt;&lt;span style="font-family:arial"&gt;”&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，俗话说&lt;/span&gt;&lt;span style="font-family:arial"&gt;“&lt;/span&gt;&lt;span style="color:red; font-family:宋体"&gt;有借就有还&lt;/span&gt;&lt;span style="font-family:arial"&gt;”&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，但这里的问题就是&lt;span style="color:red"&gt;什么时候还&lt;/span&gt;了，如果借来的工人刚完成一个任务就还回去，后来发现任务还有，那岂不是又要去借？这一来一往，老板肯定头也大死了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:arial"&gt;&lt;span style="font-size:14px"&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;合理的策略：既然借了，那就多借一会儿。直到&lt;/span&gt;&lt;span style="font-family:arial"&gt;“&lt;/span&gt;&lt;span style="color:red; font-family:宋体"&gt;某一段&lt;/span&gt;&lt;span style="font-family:arial"&gt;”&lt;/span&gt;&lt;span style="font-family:宋体"&gt;时间后，发现再也用不到这些工人时，便可以还回去了。这里的某一段时间便是&lt;/span&gt;&lt;span style="font-family:arial"&gt;keepAliveTime&lt;/span&gt;&lt;span style="font-family:宋体"&gt;的含义，&lt;/span&gt;&lt;span style="font-family:arial"&gt;TimeUnit&lt;/span&gt;&lt;span style="font-family:宋体"&gt;为&lt;/span&gt;&lt;span style="font-family:arial"&gt;keepAliveTime&lt;/span&gt;&lt;span style="font-family:宋体"&gt;值的度量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:arial"&gt;&lt;span style="font-size:14px"&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:courier new"&gt;RejectedExecutionHandler&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;另一种情况便是，即使向老板借了工人，但是任务还是继续过来，还是忙不过来，这时整个队伍只好拒绝接受了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:courier new"&gt;RejectedExecutionHandler&lt;/span&gt;&lt;span style="font-family:宋体"&gt;接口提供了对于拒绝任务的处理的自定方法的机会。在&lt;/span&gt;&lt;span style="font-family:courier new"&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中已经默认包含了&lt;/span&gt;&lt;span style="font-family:courier new"&gt;4&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中策略，因为源码非常简单，这里直接贴出来。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:courier new"&gt;CallerRunsPolicy&lt;/span&gt;&lt;/strong&gt;&lt;span style="font-family:宋体"&gt;：&lt;/span&gt;&lt;span style="font-family:宋体"&gt;线程调用运行该任务的&lt;/span&gt;&lt;span style="font-family:courier new"&gt; execute &lt;/span&gt;&lt;span style="font-family:宋体"&gt;本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;1.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {   &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;2.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            if (!e.isShutdown()) {   &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;3.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;                r.run();   &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;4.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            }   &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;5.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;        }  &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;           if (!e.isShutdown()) {&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;               r.run();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;           }&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;       }&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;这个策略显然不想放弃执行任务。但是由于池中已经没有任何资源了，那么就直接使用调用该&lt;/span&gt;&lt;span style="font-family:courier new"&gt;execute&lt;/span&gt;&lt;span style="font-family:宋体"&gt;的线程本身来执行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:courier new"&gt;AbortPolicy&lt;/span&gt;&lt;span style="font-family:宋体"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="font-family:宋体"&gt;处理程序遭到拒绝将抛出运行时&lt;/span&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="color:black"&gt;RejectedExecutionException&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;1.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {   &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;2.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            throw new RejectedExecutionException();   &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;3.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;        }  &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;           throw new RejectedExecutionException();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;       }&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:courier new"&gt; &lt;/span&gt;&lt;span style="font-family:宋体"&gt;这种策略直接抛出异常，丢弃任务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:courier new"&gt;DiscardPolicy&lt;/span&gt;&lt;span style="font-family:宋体"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="font-family:宋体"&gt;不能执行的任务将被删除&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;1.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {   &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;2.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;        }  &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;       }&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:courier new"&gt; &lt;/span&gt;&lt;span style="font-family:宋体"&gt;这种策略和&lt;/span&gt;&lt;span style="font-family:courier new"&gt;AbortPolicy&lt;/span&gt;&lt;span style="font-family:宋体"&gt;几乎一样，也是丢弃任务，只不过他不抛出异常。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;strong&gt;&lt;span style="font-family:courier new"&gt;DiscardOldestPolicy&lt;/span&gt;&lt;span style="font-family:宋体"&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span style="font-family:宋体"&gt;如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;1.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {   &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;2.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            if (!e.isShutdown()) {   &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;3.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;                e.getQueue().poll();   &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;4.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;                e.execute(r);   &lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;5.     &lt;/span&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;            }   &lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span style="font-family:courier new; font-size:7.5pt"&gt;        } &lt;/span&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt; &lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;           if (!e.isShutdown()) {&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;               e.getQueue().poll();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;               e.execute(r);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;           }&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:courier new"&gt;&lt;span style="font-size:14px"&gt;       }&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;该策略就稍微复杂一些，在&lt;/span&gt;&lt;span style="font-family:courier new"&gt;pool&lt;/span&gt;&lt;span style="font-family:宋体"&gt;没有关闭的前提下首先丢掉缓存在队列中的最早的任务，然后重新尝试运行该任务。这个策略需要适当小心。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;设想&lt;/span&gt;&lt;span style="font-family:courier new"&gt;:&lt;/span&gt;&lt;span style="font-family:宋体"&gt;如果其他线程都还在运行，那么新来任务踢掉旧任务，缓存在&lt;/span&gt;&lt;span style="font-family:courier new"&gt;queue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中，再来一个任务又会踢掉&lt;/span&gt;&lt;span style="font-family:courier new"&gt;queue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;中最老任务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;总结：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:courier new"&gt;keepAliveTime&lt;/span&gt;&lt;span style="font-family:宋体"&gt;和&lt;/span&gt;&lt;span style="font-family:courier new"&gt;maximumPoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;及&lt;/span&gt;&lt;span style="font-family:courier new"&gt;BlockingQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;的类型均有关系。如果&lt;/span&gt;&lt;span style="font-family:courier new"&gt;BlockingQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;是无界的，那么永远不会触发&lt;/span&gt;&lt;span style="font-family:courier new"&gt;maximumPoolSize&lt;/span&gt;&lt;span style="font-family:宋体"&gt;，自然&lt;/span&gt;&lt;span style="font-family:courier new"&gt;keepAliveTime&lt;/span&gt;&lt;span style="font-family:宋体"&gt;也就没有了意义。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-size:14px"&gt;&lt;span style="font-family:宋体"&gt;反之，如果核心数较小，有界&lt;/span&gt;&lt;span style="font-family:courier new"&gt;BlockingQueue&lt;/span&gt;&lt;span style="font-family:宋体"&gt;数值又较小，同时&lt;/span&gt;&lt;span style="font-family:courier new"&gt;keepAliveTime&lt;/span&gt;&lt;span style="font-family:宋体"&gt;又设的很小，如果任务频繁，那么系统就会频繁的申请回收线程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="0" cellspacing="0"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="background-color:transparent; width:426.1pt"&gt; &lt;p style="text-align:left"&gt;&lt;span style="font-family:宋体; font-size:12pt"&gt; &lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:宋体; font-size:12pt"&gt;public static ExecutorService newFixedThreadPool(int nThreads) {&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:宋体; font-size:12pt"&gt;       return new ThreadPoolExecutor(nThreads, nThreads,&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:宋体; font-size:12pt"&gt;                                     0L, TimeUnit.MILLISECONDS,&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:宋体; font-size:12pt"&gt;                                     new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span style="font-family:宋体; font-size:12pt"&gt;   }&lt;/span&gt;&lt;/p&gt;                    &lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>python黑帽子
        -  磁针石
        的个人空间 - 开源中国社区</title><link>http://my.oschina.net/u/1433482/blog/710785</link><description>&lt;div class="BlogContent"&gt;
                    &lt;span id="OSC_h3_1"&gt;&lt;/span&gt;
&lt;h3&gt;WingIDE 调试&lt;/h3&gt; 
&lt;p&gt;先准备好如下文件，存为test.py:&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-python"&gt;def sum(number_one,number_two):
    number_one_int = convert_integer(number_one)
    number_two_int = convert_integer(number_two)
    
    result = number_one_int + number_two_int
    
    return result

def convert_integer(number_string):
    
    converted_integer = int(number_string)
    return converted_integer

answer = sum("1","2")&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt; &lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;在Debug菜单，点击"Select Current as Main Debug File"&lt;/li&gt; 
 &lt;li&gt;在行return converted_integer设置断点，可以点击左边栏或者按F9。&lt;/li&gt; 
 &lt;li&gt;按F5执行，将会停在断点。&lt;/li&gt; 
 &lt;li&gt;点击左下方的Stack Data标签。可以看到包含局部和全局变量的信息。它的下拉条中可以显示当前调用堆栈。&lt;/li&gt; 
 &lt;li&gt;右下方 Debug Probe标签的python shell可以修改当前上下文。 &lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; converted_integer
1
&amp;gt;&amp;gt;&amp;gt; converted_integer =2
&amp;gt;&amp;gt;&amp;gt; converted_integer
2&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; 
 &lt;li&gt;再按F5可以恢复执行。&lt;/li&gt; 
&lt;/ul&gt;                    &lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>Apache Ignite(V1.6.0)中文开发手册 
        -  李玉珏的技术博客 - 开源中国社区</title><link>http://my.oschina.net/liyuj/blog/710774</link><description>&lt;div class="BlogContent"&gt;&lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>php新玩具：psysh
        -  何以解忧 - 开源中国社区</title><link>http://my.oschina.net/falcon10086/blog/710772</link><description>&lt;div class="BlogContent"&gt;
                    &lt;blockquote&gt; 
 &lt;table&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td&gt;&lt;img src="http://static.oschina.net/uploads/img/201607/12195807_Ckpj.jpg"/&gt;&lt;/td&gt; 
    &lt;td&gt;本文通过 &lt;a href="https://www.cellmean.com/oscpress/" rel="nofollow"&gt; OscPress &lt;/a&gt; 同步至oschina，转载请注明原文出处： &lt;a href="https://www.cellmean.com/?p=660" rel="nofollow"&gt;https://www.cellmean.com/?p=660&lt;/a&gt;&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;发现一个好玩的东东,psysh,一个php的命令行交互工具，有点像ipython： 在osx下用Composer安装，这里用的是全局安装：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;$ composer global require psy/psysh&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;安装完毕后，PsySH已经安装到/Users/{用户名}/.composer/vendor/psy/psysh目录下 此时，你可以直接运行：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;$ /Users/{用户名}/.composer/vendor/psy/psysh/bin/psysh&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;为了使用方便，建议将它加入到环境变量：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;$ echo 'export PATH="/Users/{用户名}/.composer/vendor/psy/psysh/bin:$PATH"' &amp;gt;&amp;gt;~/.zshrc
$ source ~/.zshrc&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;然后就能愉快地使用了 在运行时忘记参数怎么办？PsySH的文档功能可以让你即时查看文档。 PsySH的文档存放在~/.local/share/psysh/。（windows系统存放在C:\Users\{用户名}\AppData\Roaming\PsySH\） 在运行时忘记参数怎么办？Psysh的文档功能可以让你即时查看文档,psysh的文档放在/Users/｛用户名｝/.local/share/psysh，文档需要自行下载 以下载使用中文文档为例：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;$ cd ~/.local/share
$ mkdir psysh
$ cd psysh
$ wget http://psysh.org/manual/zh/php_manual.sqlite&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;完成后再打开psysh，输入&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;doc 函数名&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;就可以查看到函数的说明了&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;em&gt;感谢阅读本文，欢迎访问&lt;a href="https://www.cellmean.com/?p=660" rel="nofollow"&gt; 微言 &lt;/a&gt;获取更多内容或 &lt;a href="https://www.cellmean.com/?p=660" rel="nofollow"&gt; 查看原文&lt;/a&gt; &lt;/em&gt;&lt;/p&gt;                    &lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>已醉倒
        -  细雨微风轻诉流年的个人空间 - 开源中国社区</title><link>http://my.oschina.net/shaosimingbaifeng/blog/710769</link><description>&lt;div class="BlogContent"&gt;&lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item><item><title>互联网产品开发：为什么版本控制如此重要？
        -  程序员客栈 - 开源中国社区</title><link>http://my.oschina.net/proginn/blog/710766</link><description>&lt;div class="BlogContent"&gt;
                    &lt;p style="text-align: center;"&gt;&lt;img src="http://img.mp.itc.cn/upload/20160712/c58a2e12b0eb4e6c8a11911a11d58c34_th.png"/&gt;&lt;/p&gt; 
&lt;p&gt;　　如果说什么是软件开发项目一定要使用的基础工具，那么版本控制系统应该算最重要的部分。不管是个人开发或是团队协作开发，都可以通过版本控制系统获得巨大的好处。&lt;/p&gt; 
&lt;p&gt;　　没有版本控制系统的话，代码可能被别人或自己不小心覆盖或遗失、也不知道是谁因为什么原因改了这段代码、也没办法可以复原回前几天的修改。有了版本控制系统，开发人员只要将每次程式码的变更都纪录（Commit）起来，并且透过版本控制系统中进行更新。&lt;/p&gt; 
&lt;p&gt;　　有了版本控制系统，我们可以浏览所有开发的历史纪录，掌握团队的开发进度，而且作任何修改都不再害怕，因为你可以轻易的复原回之前正常的版本。我们也可以透过分支和标签的功能来进行软件发行的不同版本，例如稳定版本、维护版本和开发中版本。&lt;/p&gt; 
&lt;p&gt;　　很多项目需求方还没有明白开发的定义，这里必须要跟大家说一点老生常谈的段子：“开发永远是个过程，而不是结果。”所以开发者一定要使用版本控制系统，Git或Mercurial是免费开源的版本系统系统、随处可用的网络、便宜的云端服务器，甚至有现成的第三方服务Github。&lt;/p&gt; 
&lt;p&gt;　　如果你还没有使用的话，建议马上为你的软件开发项目建立版本控制。接下来是几点使用版本控制系统的建议：&lt;/p&gt; 
&lt;p&gt;　　1.将所有东西都放进版本控制系统&lt;/p&gt; 
&lt;p&gt;　　是的，所有项目开发过程中的产出物都放到版本控制系统之中，这包括了程序源代码、测试程序、文件、设定档、各种自动化脚本等等。除了新成员可以很容易拉出最新的版本马上开始工作之外，我们也希望在测试环境、正式环境中，也可以随时更新到我们所指定的版本，因此将所有变更的纪录保存起来是非常重要的。&lt;/p&gt; 
&lt;p&gt;　　例如，数据库的变更也必须纳入版本控制。首先，在数据库中纪录它目前的版本编号。接着我们每次的修改都透过一个自动化脚本来执行，并将这个脚本放入版本控制之中，而不是手动用指令去修改纲要。这样的好处是团队中每个人都可以透过版本控制系统看到这个变更，并且升级他的数据库。测试和正式的服务器环境，也会透过这个脚本来自动进行升级。笔者熟悉的Ruby on Rails中就有内置这样的Migration机制，其他程序语言也有类似的数据库工具。&lt;/p&gt; 
&lt;p&gt;　　另外，以服务器应用来说，光是有源代码还是无法100%让软件工作起来，我们还需要知道服务器的配置设定，包括基础网络设定、操作系统设定、依赖的套件版本等等。因此最好这些配置设定也可以纳入版本管理系统之中。近年来云端技术的进步，已经可以将这些基础设施设定当作程序，无缝地让每个成员和所有环境都使用完全相同的设定，减少出错的可能性。&lt;/p&gt; 
&lt;p&gt;　　2.频繁且适当大小的递交&lt;/p&gt; 
&lt;p&gt;　　如果久久才递交一次修改到版本控制系统，那么你只是把版本控制系统当作一种备份工具而已，而没有享受到它真正的好处。频繁的递交可以帮助团队开发进度的透明化，减少多人开发时的代码冲突。当多人同时修改同一块代码时，解决代码冲突是很麻烦的事情。还有，我们也希望每一次的递交有适当的粒度大小，也就是每个提交的内容应该有高度相关性和独立性。例如是一个小功能或是一个小改进。如果你同时在做新功能A和修旧Bug，那么就应该分开两次递交。语法错误无法建构的程序也不应该提交从而造成团队困扰。&lt;/p&gt; 
&lt;p&gt;　　有良好大小的代码提交习惯的好处除了版本的历史纪录更加清楚之外，我们可以非常轻易的做代码的复原或移植，假设上述的新功能A有问题，我们可以只复原A而不影响修好的Bug，或是只挑选修Bug的移植到不同分支去。&lt;/p&gt; 
&lt;p&gt;　　3.良好的递交信息&lt;/p&gt; 
&lt;p&gt;　　每一次的递交&lt;a href="https://www.proginn.com/" rel="nofollow" target="_blank"&gt;程序员&lt;/a&gt;都必须附上一段解释信息，说明修改的内容和原因。这除了可以帮助团队合作之外，更重要的是让软件有更好的维护性，以便将来备查，以下的场景相信开发者都不陌生：&lt;/p&gt; 
&lt;p&gt;　　软件发现一个Bug，然后指派给你修复。&lt;/p&gt; 
&lt;p&gt;　　你追代码追到一段看不懂的程序，也没有任何注释。&lt;/p&gt; 
&lt;p&gt;　　透过版本控制系统，你找到了同事在一年前加了这行，递交的信息是BUG或简单的错误提示。&lt;/p&gt; 
&lt;p&gt;　　同事还在公司，可是他也不记得当初是哪一个BUG了。或是他已经下班或离职了，反正找不到。&lt;/p&gt; 
&lt;p&gt;　　你强行改了这行代码，发布出去。&lt;/p&gt; 
&lt;p&gt;　　这个功能是修好了，但是发现另一个功能又出现问题。&lt;/p&gt; 
&lt;p&gt;　　继续加班到凌晨，悲催ing....&lt;/p&gt; 
&lt;p&gt;　　一个好的递交信息应该包括一行摘要信息，描述你为什么做这段变更，可能是新增、移除、修正某个功能，而不是描述新增或修改哪些档案，重点应放在备注为什么修改而不是这段是bug这么简单。因为修改了哪些档案和行数我们看版本差异就知道了，无须重复描述。如果你发现很难摘要，那可能表示你包含太多变更在同一次递交了，请试着拆开。&lt;/p&gt;                    &lt;/div&gt;</description><pubDate>2016-07-12</pubDate></item></channel></rss>